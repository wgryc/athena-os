{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to ATHENA","text":"<p>Track your portfolio, individual positions, forex, and other financial instruments in one place. Pull data from the Federal Reserve, Yahoo! Finance, and custom sources. Track metrics to benchmark yourself against hedge funds. Use LLMs to manage your portfolio.</p> <p>Athena is a toolkit designed to easily track investments and delegate decision-making to a large language model. Our vision is to have LLMs help with tracking major news developments, run scenario analyses, and ultimately open and close positions.</p> <p>The data structure lives in Excel; it can be edited by you to input positions, override choices, or incorporate your existing portfolios.</p> <p>This is an experimental toolkit. It should be used to inform your research and does not represent any sort of official investment advice.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>If you'd like to contribute, please reach out to hello@emergingtrajectories.com.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Install via <code>pip</code>:</p> <pre><code>pip install athenaos\n</code></pre> <p>Install via GitHub:</p> <pre><code>pip install git+https://github.com/wgryc/athena-os.git\n</code></pre> <p>If you are cloning the repo and installing from local source, run the following: <code>pip install -e .</code> or <code>pip install -e \".[dev]\"</code> to run tests.</p>"},{"location":"reference/agents/","title":"agents","text":""},{"location":"reference/agents/#athena.agents","title":"<code>athena.agents</code>","text":""},{"location":"reference/agents/#athena.agents.run_investing_agent","title":"<code>run_investing_agent(portfolio_file_name, project_code, events_section_title, events_description, data_source_description, data_summary_description, generate_summary=False, system_prompt_file='system_prompt.j2', pricing_manager=None, use_commodities=False, short_ok=False)</code>","text":"<p>Run the investing agent with the given configuration.</p> <p>Loads the portfolio, builds a system prompt, generates an initial message, and enters a conversation loop with the LLM that can execute QUOTE, BUY, and SELL commands. Saves the portfolio after the loop completes.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio_file_name</code> <code>str</code> <p>Path to the portfolio Excel file.</p> required <code>project_code</code> <code>str</code> <p>The project code for fetching events.</p> required <code>events_section_title</code> <code>str</code> <p>Title for the events section.</p> required <code>events_description</code> <code>str</code> <p>Description of the events data.</p> required <code>data_source_description</code> <code>str</code> <p>Description of the data source.</p> required <code>data_summary_description</code> <code>str</code> <p>Description for the data summary.</p> required <code>generate_summary</code> <code>bool</code> <p>Whether to generate an email summary at the end.</p> <code>False</code> <code>system_prompt_file</code> <code>str</code> <p>Jinja2 template filename for the system prompt.</p> <code>'system_prompt.j2'</code> <code>pricing_manager</code> <p>Optional pricing manager passed to portfolio loading.</p> <code>None</code> <code>use_commodities</code> <code>bool</code> <p>If True, use commodity futures quote functions instead of stock quote functions.</p> <code>False</code> <code>short_ok</code> <code>bool</code> <p>If True, allow short selling and use corresponding prompt templates.</p> <code>False</code> <p>Returns:</p> Type Description <p>The email summary string if <code>generate_summary</code> is True,</p> <p>otherwise an empty string.</p> Source code in <code>src/athena/agents/agents.py</code> <pre><code>def run_investing_agent(\n    portfolio_file_name: str,\n    project_code: str,\n    events_section_title: str,\n    events_description: str,\n    data_source_description: str,\n    data_summary_description: str,\n    generate_summary: bool = False,\n    system_prompt_file:str = \"system_prompt.j2\",\n    pricing_manager = None,\n    use_commodities: bool = False,\n    short_ok: bool = False\n):\n    \"\"\"Run the investing agent with the given configuration.\n\n    Loads the portfolio, builds a system prompt, generates an initial message,\n    and enters a conversation loop with the LLM that can execute QUOTE, BUY,\n    and SELL commands. Saves the portfolio after the loop completes.\n\n    Args:\n        portfolio_file_name: Path to the portfolio Excel file.\n        project_code: The project code for fetching events.\n        events_section_title: Title for the events section.\n        events_description: Description of the events data.\n        data_source_description: Description of the data source.\n        data_summary_description: Description for the data summary.\n        generate_summary: Whether to generate an email summary at the end.\n        system_prompt_file: Jinja2 template filename for the system prompt.\n        pricing_manager: Optional pricing manager passed to portfolio loading.\n        use_commodities: If True, use commodity futures quote functions\n            instead of stock quote functions.\n        short_ok: If True, allow short selling and use corresponding\n            prompt templates.\n\n    Returns:\n        The email summary string if ``generate_summary`` is True,\n        otherwise an empty string.\n    \"\"\"\n    portfolio = load_portfolio_from_excel(\n        portfolio_file_name,\n        primary_currency=Currency.USD,\n        create_if_missing=True,\n        error_out_negative_cash=False,\n        error_out_negative_quantity=True,\n        pricing_manager=pricing_manager,\n    )\n\n    # Override system prompt if short_ok is True and the default system prompt is being used.\n    if short_ok and system_prompt_file == \"system_prompt.j2\":\n        system_prompt_file = \"system_prompt_short_ok.j2\"\n\n    system_prompt = get_system_prompt(data_source_description, data_summary_description, system_prompt_file=system_prompt_file)\n    initial_message = generate_initial_message(\n        portfolio, project_code, events_section_title, events_description, use_commodities=use_commodities\n    )\n\n    messages_array = [\n                        {\n                            \"role\": \"user\",\n                            \"content\": initial_message\n                        }\n                    ]\n\n    func_get_quote = commodities_get_quote if use_commodities else get_quote\n    func_get_quote_for_context = commodities_get_quote_for_context if use_commodities else get_quote_for_context\n\n    while True:\n\n        response = stream_llm_response(\n            system_prompt=system_prompt,\n            messages=messages_array,\n            model=DEFAULT_ANTHROPIC_MODEL\n        )\n\n        messages_array.append(\n            {\n                \"role\": \"assistant\",\n                \"content\": response\n            }\n        )\n\n        # print(\"Response from Anthropic:\")\n        # print(response)\n\n        quotes_request = False\n        new_content = \"\"\n\n        if response.find(\"|--COMMAND--|\") != -1:\n            command_section = response.split(\"|--COMMAND--|\")[1]\n            command_section = command_section.strip()\n            lines = command_section.split(\"\\n\")\n            # print(lines)\n            for line in lines:\n                line = line.strip()\n                if line.startswith(\"QUOTE:\"):\n                    quotes_request = True\n                    line = line.replace(\"QUOTE:\", \"\").strip()\n                    symbols = line.split(\",\")\n                    for symbol in symbols:\n                        symbol = symbol.strip()\n                        print(f\"Fetching quote for symbol: {symbol}\")\n                        quote_for_context = func_get_quote_for_context(symbol)\n                        new_content += f\"\\n{quote_for_context}\\n\"\n                elif line.startswith(\"BUY:\"):\n                    line = line.replace(\"BUY:\", \"\").strip()\n                    parts = line.split(\",\")\n                    for part in parts:\n                        toks = part.strip().split(\"|\")\n                        if len(toks) == 2:\n                            symbol = toks[0].strip()\n                            quantity = toks[1].strip()\n                            ask_price, bid_price = func_get_quote(symbol)\n                            if ask_price == -1.0 and bid_price == -1.0:\n                                print(f\"Error fetching quote for {symbol}. Skipping BUY order.\\n\")\n                                continue\n                            print(f\"Placing BUY order for {quantity} shares of {symbol}\\n\")\n                            transaction = portfolio.add_transaction_now(\n                                symbol=symbol,\n                                transaction_type=TransactionType.BUY,\n                                quantity=Decimal(quantity),\n                                price=ask_price  # type: ignore[arg-type]\n                            )\n                        else:\n                            print(f\"Invalid BUY command format: {part}\\n\")\n                elif line.startswith(\"SELL:\"):\n                    line = line.replace(\"SELL:\", \"\").strip()\n                    parts = line.split(\",\")\n                    for part in parts:\n                        toks = part.strip().split(\"|\")\n                        if len(toks) == 2:\n                            symbol = toks[0].strip()\n                            quantity = toks[1].strip()\n                            # Check if shorting is allowed\n                            if not short_ok:\n                                current_positions = get_positions(datetime.now(timezone.utc), portfolio)\n                                position_qty = Decimal(\"0\")\n                                for pos in current_positions:\n                                    if pos.symbol == symbol:\n                                        position_qty = pos.quantity\n                                        break\n                                if position_qty &lt; Decimal(quantity):\n                                    print(f\"Invalid SELL command: shorting is not allowed for {symbol}\\n\")\n                                    continue\n                            ask_price, bid_price = func_get_quote(symbol)\n                            if ask_price == -1.0 and bid_price == -1.0:\n                                print(f\"Error fetching quote for {symbol}. Skipping SELL order.\\n\")\n                                continue\n                            print(f\"Placing SELL order for {quantity} shares of {symbol}\\n\")\n                            transaction = portfolio.add_transaction_now(\n                                symbol=symbol,\n                                transaction_type=TransactionType.SELL,\n                                quantity=Decimal(quantity),\n                                price=bid_price  # type: ignore[arg-type]\n                            )\n                        else:\n                            print(f\"Invalid SELL command format: {part}\\n\")\n                else:\n                    print(f\"Unknown command: {line}\\n\")\n\n        if quotes_request:\n            print(\"\\n\\n\\nSENDING MESSAGE TO ANTHROPIC:\\n\")\n            print(new_content)\n            messages_array.append(\n                {\n                    \"role\": \"user\",\n                    \"content\": new_content.strip()\n                }\n            )\n        else:\n            break \n\n    save_portfolio_to_excel(portfolio, portfolio_file_name)\n\n    if generate_summary:\n        email_instructions = get_email_summary_instructions()\n        messages_array.append({\n            \"role\": \"user\",\n            \"content\": email_instructions\n        })\n        summary_response = stream_llm_response(\n            system_prompt=email_instructions,\n            messages=messages_array,\n            model=DEFAULT_ANTHROPIC_MODEL\n        )\n        messages_array.append(\n            {\n                \"role\": \"assistant\",\n                \"content\": summary_response\n            }\n        )\n\n        print(json.dumps(messages_array, indent=4))\n\n        return summary_response\n\n    return \"\"\n</code></pre>"},{"location":"reference/agents/#athena.agents.get_quote","title":"<code>get_quote(symbol)</code>","text":"<p>Get the latest ask/bid quote for a stock symbol via the Massive API.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Stock ticker symbol (e.g., \"AAPL\").</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>A tuple of (ask_price, bid_price). Returns (-1.0, -1.0) on error.</p> Source code in <code>src/athena/agents/agents.py</code> <pre><code>def get_quote(symbol: str) -&gt; tuple[float, float]:\n    \"\"\"Get the latest ask/bid quote for a stock symbol via the Massive API.\n\n    Args:\n        symbol: Stock ticker symbol (e.g., \"AAPL\").\n\n    Returns:\n        A tuple of (ask_price, bid_price). Returns (-1.0, -1.0) on error.\n    \"\"\"\n    try:\n        client = RESTClient(MASSIVE_API_KEY)\n        quote = client.get_last_quote(symbol)\n        return quote.ask_price, quote.bid_price # type: ignore\n    except Exception as e:\n        print(f\"Error fetching quote for {symbol}: {e}\")\n        return -1.0, -1.0\n</code></pre>"},{"location":"reference/agents/#athena.agents.get_quote_for_context","title":"<code>get_quote_for_context(symbol)</code>","text":"<p>Get comprehensive quote information for a stock symbol for LLM context.</p> <p>Includes bid/ask, current day OHLC (if market open), and price movements.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Stock ticker symbol (e.g., \"AAPL\").</p> required <p>Returns:</p> Type Description <code>str</code> <p>A newline-joined string with stock info, bid/ask prices, market</p> <code>str</code> <p>status, OHLC data, and 1-week/1-month/1-year price changes.</p> Source code in <code>src/athena/agents/agents.py</code> <pre><code>def get_quote_for_context(symbol: str) -&gt; str:\n    \"\"\"Get comprehensive quote information for a stock symbol for LLM context.\n\n    Includes bid/ask, current day OHLC (if market open), and price movements.\n\n    Args:\n        symbol: Stock ticker symbol (e.g., \"AAPL\").\n\n    Returns:\n        A newline-joined string with stock info, bid/ask prices, market\n        status, OHLC data, and 1-week/1-month/1-year price changes.\n    \"\"\"\n    client = RESTClient(MASSIVE_API_KEY)\n    result_parts = []\n    result_parts.append(f\"Stock: {symbol}\")\n\n    # 1. Get current bid/ask\n    try:\n        quote = client.get_last_quote(symbol)\n        bid_price = quote.bid_price\n        ask_price = quote.ask_price\n        result_parts.append(f\"Current Bid: ${bid_price:.2f}, Ask: ${ask_price:.2f}, Spread: ${(ask_price - bid_price):.2f}\")\n    except Exception as e:\n        result_parts.append(f\"Bid/Ask: Unable to fetch ({e})\")\n        return \"\\n\".join(result_parts)\n\n    # 2. Check if market is currently open and get today's OHLC\n    et_tz = ZoneInfo('America/New_York')\n    now_et = datetime.now(et_tz)\n    market_open_time = now_et.replace(hour=9, minute=30, second=0, microsecond=0)\n    market_close_time = now_et.replace(hour=16, minute=0, second=0, microsecond=0)\n    is_weekday = now_et.weekday() &lt; 5  # Monday = 0, Friday = 4\n    is_market_hours = market_open_time &lt;= now_et &lt;= market_close_time\n    market_is_open = is_weekday and is_market_hours\n\n    today_str = now_et.strftime(\"%Y-%m-%d\")\n    current_price = None\n\n    if market_is_open:\n        try:\n            aggs = list(client.list_aggs(\n                ticker=symbol,\n                multiplier=1,\n                timespan=\"day\",\n                from_=today_str,\n                to=today_str,\n                limit=1\n            ))\n            if aggs:\n                today_agg = aggs[0]\n                current_price = today_agg.close\n                result_parts.append(f\"Today (Market Open): Price: ${today_agg.close:.2f}, Open: ${today_agg.open:.2f}, High: ${today_agg.high:.2f}, Low: ${today_agg.low:.2f}\")\n        except Exception as e:\n            result_parts.append(f\"Today's OHLC: Unable to fetch ({e})\")\n    else:\n        result_parts.append(\"Market Status: Closed\")\n\n    # 3-5. Get price movements for 1 week, 1 month, 1 year\n    now_utc = datetime.now(timezone.utc)\n    one_week_ago = (now_utc - timedelta(days=10)).strftime(\"%Y-%m-%d\")  # Extra days to account for weekends\n    one_month_ago = (now_utc - timedelta(days=35)).strftime(\"%Y-%m-%d\")\n    one_year_ago = (now_utc - timedelta(days=370)).strftime(\"%Y-%m-%d\")\n\n    try:\n        # Get recent data to find current price if we don't have it\n        recent_aggs = list(client.list_aggs(\n            ticker=symbol,\n            multiplier=1,\n            timespan=\"day\",\n            from_=one_week_ago,\n            to=today_str,\n            limit=50\n        ))\n\n        if recent_aggs:\n            if current_price is None:\n                current_price = recent_aggs[-1].close\n                result_parts.append(f\"Last Close: ${current_price:.2f}\")\n\n            # Week ago: find price from ~5-7 trading days ago\n            week_ago_price = recent_aggs[0].close if len(recent_aggs) &gt;= 5 else None\n\n            # Get month ago price\n            month_aggs = list(client.list_aggs(\n                ticker=symbol,\n                multiplier=1,\n                timespan=\"day\",\n                from_=one_month_ago,\n                to=(now_utc - timedelta(days=25)).strftime(\"%Y-%m-%d\"),\n                limit=5\n            ))\n            month_ago_price = month_aggs[-1].close if month_aggs else None\n\n            # Get year ago price\n            year_aggs = list(client.list_aggs(\n                ticker=symbol,\n                multiplier=1,\n                timespan=\"day\",\n                from_=one_year_ago,\n                to=(now_utc - timedelta(days=360)).strftime(\"%Y-%m-%d\"),\n                limit=5\n            ))\n            year_ago_price = year_aggs[-1].close if year_aggs else None\n\n            # Build price movement summary\n            movements = []\n            if week_ago_price and current_price:\n                week_change = current_price - week_ago_price\n                week_pct = (week_change / week_ago_price) * 100\n                movements.append(f\"1-Week: {week_change:+.2f} ({week_pct:+.1f}%)\")\n\n            if month_ago_price and current_price:\n                month_change = current_price - month_ago_price\n                month_pct = (month_change / month_ago_price) * 100\n                movements.append(f\"1-Month: {month_change:+.2f} ({month_pct:+.1f}%)\")\n\n            if year_ago_price and current_price:\n                year_change = current_price - year_ago_price\n                year_pct = (year_change / year_ago_price) * 100\n                movements.append(f\"1-Year: {year_change:+.2f} ({year_pct:+.1f}%)\")\n\n            if movements:\n                result_parts.append(\"Price Changes: \" + \", \".join(movements))\n    except Exception as e:\n        result_parts.append(f\"Price Movements: Unable to fetch ({e})\")\n\n    return \"\\n\".join(result_parts)\n</code></pre>"},{"location":"reference/agents/#athena.agents.stream_llm_response","title":"<code>stream_llm_response(system_prompt, messages, model)</code>","text":"<p>Send messages to an Anthropic LLM and return the response text.</p> <p>Retries up to 3 times with exponential backoff on failure.</p> <p>Parameters:</p> Name Type Description Default <code>system_prompt</code> <code>str</code> <p>The system prompt to prepend to the conversation.</p> required <code>messages</code> <code>list[dict[str, str]]</code> <p>List of message dicts with \"role\" and \"content\" keys.</p> required <code>model</code> <code>str</code> <p>Anthropic model name (e.g., \"claude-sonnet-4-5\").</p> required <p>Returns:</p> Type Description <code>str</code> <p>The text content of the model's response.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Re-raises the last exception after all retry attempts are exhausted.</p> Source code in <code>src/athena/agents/agents.py</code> <pre><code>def stream_llm_response(system_prompt: str, messages: list[dict[str, str]], model: str) -&gt; str:\n    \"\"\"Send messages to an Anthropic LLM and return the response text.\n\n    Retries up to 3 times with exponential backoff on failure.\n\n    Args:\n        system_prompt: The system prompt to prepend to the conversation.\n        messages: List of message dicts with \"role\" and \"content\" keys.\n        model: Anthropic model name (e.g., \"claude-sonnet-4-5\").\n\n    Returns:\n        The text content of the model's response.\n\n    Raises:\n        Exception: Re-raises the last exception after all retry attempts\n            are exhausted.\n    \"\"\"\n    max_num_attempts = 3\n    num_attempts = 0\n\n    # Format model name for litellm (prefix with anthropic/)\n    litellm_model = f\"anthropic/{model}\"\n    litellm_messages = [{\"role\": \"system\", \"content\": system_prompt}] + messages\n\n    while num_attempts &lt; max_num_attempts:\n        try:\n            response = litellm.completion(\n                model=litellm_model,\n                messages=litellm_messages,\n                max_tokens=8192,\n            )\n            return response.choices[0].message.content  # type: ignore\n\n        except Exception as e:\n            print(f\"Attempt {num_attempts} failed: {e}\")\n            print(f\"Retrying after {SLEEP_TIMES_FOR_ANTHROPIC[num_attempts]} seconds...\")\n            time.sleep(SLEEP_TIMES_FOR_ANTHROPIC[num_attempts])\n            num_attempts += 1\n\n            if num_attempts &gt;= max_num_attempts:\n                raise e\n\n    return \"\"  # Should never reach here\n</code></pre>"},{"location":"reference/agents/#athena.agents.generate_initial_message","title":"<code>generate_initial_message(portfolio, project_code, events_section_title, events_description, use_commodities=False, short_ok=False)</code>","text":"<p>Generate the initial user message from a Jinja2 template.</p> <p>Fetches events data, calculates portfolio values, and optionally includes available commodity contracts to compose the first message sent to the LLM.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>The portfolio to summarize in the message.</p> required <code>project_code</code> <code>str</code> <p>The Emerging Trajectories project code for events.</p> required <code>events_section_title</code> <code>str</code> <p>Title for the events section in the message.</p> required <code>events_description</code> <code>str</code> <p>Description of the events data source.</p> required <code>use_commodities</code> <code>bool</code> <p>If True, include available futures contract info.</p> <code>False</code> <code>short_ok</code> <code>bool</code> <p>If True, use the short-selling-enabled message template.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>The rendered initial message string ready to send to the LLM.</p> Source code in <code>src/athena/agents/agents.py</code> <pre><code>def generate_initial_message(\n    portfolio: Portfolio,\n    project_code: str,\n    events_section_title: str,\n    events_description: str,\n    use_commodities: bool = False,\n    short_ok: bool = False\n) -&gt; str:\n    \"\"\"Generate the initial user message from a Jinja2 template.\n\n    Fetches events data, calculates portfolio values, and optionally includes\n    available commodity contracts to compose the first message sent to the LLM.\n\n    Args:\n        portfolio: The portfolio to summarize in the message.\n        project_code: The Emerging Trajectories project code for events.\n        events_section_title: Title for the events section in the message.\n        events_description: Description of the events data source.\n        use_commodities: If True, include available futures contract info.\n        short_ok: If True, use the short-selling-enabled message template.\n\n    Returns:\n        The rendered initial message string ready to send to the LLM.\n    \"\"\"\n    current_time = datetime.now(timezone.utc)\n\n    # Fetch events data\n    etep = EmergingTrajectoriesEventsProxy(ET_API_KEY)\n    events_data = etep.get_events(project_code)\n\n    # Calculate portfolio data\n    total_market_value = calculate_portfolio_value_on_date(portfolio, current_time, Currency.USD)\n\n    # Generate available contracts section for commodities\n    available_contracts_section = \"\"\n    if use_commodities:\n        front_months = commodities_get_front_month_symbols()\n        available_contracts_section = \"\"\"|--AVAILABLE CONTRACTS--|\n\nYou can trade the following futures contracts:\n- Natural Gas (NG): NGF26, NGG26, NGH26, etc. (10,000 MMBtu per contract) - uses 2-digit year\n- WTI Crude (CL): CLF6, CLG6, CLH6, etc. (1,000 barrels per contract) - uses 1-digit year\n- RBOB Gasoline (RB): RBF6, RBG6, RBH6, etc. (42,000 gallons per contract) - uses 1-digit year\n\nSymbol format: [ROOT][MONTH][YEAR]\nMonth codes: F=Jan, G=Feb, H=Mar, J=Apr, K=May, M=Jun, N=Jul, Q=Aug, U=Sep, V=Oct, X=Nov, Z=Dec\n\nSuggested liquid contracts (front months): \"\"\" + \", \".join(front_months) + \"\\n\"\n\n    # Choose the right inital message.\n    if short_ok:\n        initial_message_file = \"initial_message_short_ok.j2\"\n    else:\n        initial_message_file = \"initial_message.j2\"\n\n    # Render template\n    template = jinja_env.get_template(initial_message_file)\n    return template.render(\n        current_datetime=current_time.isoformat(),\n        events_section_title=events_section_title,\n        events_description=events_description,\n        events_data=events_data,\n        positions_table=format_positions_table(portfolio, current_time),\n        cash_balances=format_cash_balances(portfolio, current_time),\n        total_market_value=total_market_value,\n        transaction_log=format_transaction_log(portfolio),\n        available_contracts_section=available_contracts_section,\n    )\n</code></pre>"},{"location":"reference/agents/#athena.agents.get_system_prompt","title":"<code>get_system_prompt(data_source_description, data_summary_description, system_prompt_file='system_prompt.j2')</code>","text":"<p>Generate system prompt from a Jinja2 template.</p> <p>Parameters:</p> Name Type Description Default <code>data_source_description</code> <code>str</code> <p>Description of the data source to inject into the prompt.</p> required <code>data_summary_description</code> <code>str</code> <p>Description of the data summary to inject into the prompt.</p> required <code>system_prompt_file</code> <code>str</code> <p>Jinja2 template filename for the system prompt.</p> <code>'system_prompt.j2'</code> <p>Returns:</p> Type Description <code>str</code> <p>The rendered system prompt string.</p> Source code in <code>src/athena/agents/agents.py</code> <pre><code>def get_system_prompt(data_source_description: str, data_summary_description: str, system_prompt_file:str = \"system_prompt.j2\",) -&gt; str:\n    \"\"\"Generate system prompt from a Jinja2 template.\n\n    Args:\n        data_source_description: Description of the data source to inject\n            into the prompt.\n        data_summary_description: Description of the data summary to inject\n            into the prompt.\n        system_prompt_file: Jinja2 template filename for the system prompt.\n\n    Returns:\n        The rendered system prompt string.\n    \"\"\"\n    template = jinja_env.get_template(system_prompt_file)\n    return template.render(\n        data_source_description=data_source_description,\n        data_summary_description=data_summary_description,\n    )\n</code></pre>"},{"location":"reference/agents/#athena.agents.get_email_summary_instructions","title":"<code>get_email_summary_instructions()</code>","text":"<p>Load email summary instructions from a Jinja2 template.</p> <p>Returns:</p> Type Description <code>str</code> <p>The rendered email summary instructions string.</p> Source code in <code>src/athena/agents/agents.py</code> <pre><code>def get_email_summary_instructions() -&gt; str:\n    \"\"\"Load email summary instructions from a Jinja2 template.\n\n    Returns:\n        The rendered email summary instructions string.\n    \"\"\"\n    template = jinja_env.get_template(\"email_summary.j2\")\n    return template.render()\n</code></pre>"},{"location":"reference/cli/","title":"cli","text":""},{"location":"reference/cli/#athena.cli","title":"<code>athena.cli</code>","text":"<p>ATHENA CLI - Command line interface for agenticportfolio.</p>"},{"location":"reference/core/","title":"core","text":""},{"location":"reference/core/#athena","title":"<code>athena</code>","text":""},{"location":"reference/currency/","title":"currency","text":""},{"location":"reference/currency/#athena.currency","title":"<code>athena.currency</code>","text":""},{"location":"reference/currency/#athena.currency.Currency","title":"<code>Currency</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Supported currencies for exchange rate conversions.</p> Source code in <code>src/athena/currency.py</code> <pre><code>class Currency(Enum):\n    \"\"\"Supported currencies for exchange rate conversions.\"\"\"\n\n    USD = \"USD\"\n    CAD = \"CAD\"\n    EUR = \"EUR\"\n    TWD = \"TWD\"\n    SGD = \"SGD\"\n    AUD = \"AUD\"\n    JPY = \"JPY\"\n    KRW = \"KRW\"\n    GBP = \"GBP\"\n    BRL = \"BRL\"\n    CNY = \"CNY\"\n    HKD = \"HKD\"\n    MXN = \"MXN\"\n    ZAR = \"ZAR\"\n    CHF = \"CHF\"\n    THB = \"THB\"\n</code></pre>"},{"location":"reference/currency/#athena.currency.ExchangeRateManager","title":"<code>ExchangeRateManager</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for currency exchange rate providers.</p> Source code in <code>src/athena/currency.py</code> <pre><code>class ExchangeRateManager(ABC):\n    \"\"\"Abstract base class for currency exchange rate providers.\"\"\"\n\n    def __init__(self, min_datetime:datetime|None = None, max_datetime:datetime|None = None):\n        \"\"\"Initialize the exchange rate manager.\n\n        Args:\n            min_datetime: Earliest date for which rates are available.\n            max_datetime: Latest date for which rates are available.\n        \"\"\"\n        self.min_datetime = min_datetime\n        self.max_datetime = max_datetime\n\n    @abstractmethod\n    def get_exchange_rate(self, from_currency: Currency, to_currency: Currency, datetime:datetime|None = None) -&gt; Decimal:\n        \"\"\"Get the exchange rate between two currencies.\n\n        Args:\n            from_currency: The source currency.\n            to_currency: The target currency.\n            datetime: The date for the rate lookup. If None, uses the current date.\n\n        Returns:\n            The exchange rate as a Decimal.\n\n        Raises:\n            NotImplementedError: Always, must be overridden by subclasses.\n        \"\"\"\n        raise NotImplementedError(\"This method should be overridden by subclasses.\")\n</code></pre>"},{"location":"reference/currency/#athena.currency.ExchangeRateManager.__init__","title":"<code>__init__(min_datetime=None, max_datetime=None)</code>","text":"<p>Initialize the exchange rate manager.</p> <p>Parameters:</p> Name Type Description Default <code>min_datetime</code> <code>datetime | None</code> <p>Earliest date for which rates are available.</p> <code>None</code> <code>max_datetime</code> <code>datetime | None</code> <p>Latest date for which rates are available.</p> <code>None</code> Source code in <code>src/athena/currency.py</code> <pre><code>def __init__(self, min_datetime:datetime|None = None, max_datetime:datetime|None = None):\n    \"\"\"Initialize the exchange rate manager.\n\n    Args:\n        min_datetime: Earliest date for which rates are available.\n        max_datetime: Latest date for which rates are available.\n    \"\"\"\n    self.min_datetime = min_datetime\n    self.max_datetime = max_datetime\n</code></pre>"},{"location":"reference/currency/#athena.currency.ExchangeRateManager.get_exchange_rate","title":"<code>get_exchange_rate(from_currency, to_currency, datetime=None)</code>  <code>abstractmethod</code>","text":"<p>Get the exchange rate between two currencies.</p> <p>Parameters:</p> Name Type Description Default <code>from_currency</code> <code>Currency</code> <p>The source currency.</p> required <code>to_currency</code> <code>Currency</code> <p>The target currency.</p> required <code>datetime</code> <code>datetime | None</code> <p>The date for the rate lookup. If None, uses the current date.</p> <code>None</code> <p>Returns:</p> Type Description <code>Decimal</code> <p>The exchange rate as a Decimal.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always, must be overridden by subclasses.</p> Source code in <code>src/athena/currency.py</code> <pre><code>@abstractmethod\ndef get_exchange_rate(self, from_currency: Currency, to_currency: Currency, datetime:datetime|None = None) -&gt; Decimal:\n    \"\"\"Get the exchange rate between two currencies.\n\n    Args:\n        from_currency: The source currency.\n        to_currency: The target currency.\n        datetime: The date for the rate lookup. If None, uses the current date.\n\n    Returns:\n        The exchange rate as a Decimal.\n\n    Raises:\n        NotImplementedError: Always, must be overridden by subclasses.\n    \"\"\"\n    raise NotImplementedError(\"This method should be overridden by subclasses.\")\n</code></pre>"},{"location":"reference/currency/#athena.currency.FixedExchangeRateManager","title":"<code>FixedExchangeRateManager</code>","text":"<p>               Bases: <code>ExchangeRateManager</code></p> <p>Exchange rate manager using fixed, hardcoded rates.</p> <p>Provides static exchange rates that do not vary by date. Useful for testing or when live rates are not needed.</p> Source code in <code>src/athena/currency.py</code> <pre><code>class FixedExchangeRateManager(ExchangeRateManager):\n    \"\"\"Exchange rate manager using fixed, hardcoded rates.\n\n    Provides static exchange rates that do not vary by date. Useful for\n    testing or when live rates are not needed.\n    \"\"\"\n\n    global_exchange_rates = {\n        (Currency.USD, Currency.CAD): Decimal(\"1.25\"),\n        (Currency.CAD, Currency.USD): Decimal(\"0.80\"),\n        (Currency.USD, Currency.EUR): Decimal(\"0.85\"),\n        (Currency.EUR, Currency.USD): Decimal(\"1.18\"),\n        (Currency.USD, Currency.TWD): Decimal(\"27.5\"),\n        (Currency.TWD, Currency.USD): Decimal(\"0.036\"),\n        (Currency.USD, Currency.SGD): Decimal(\"1.35\"),\n        (Currency.SGD, Currency.USD): Decimal(\"0.74\"),\n        (Currency.USD, Currency.AUD): Decimal(\"1.55\"),\n        (Currency.AUD, Currency.USD): Decimal(\"0.65\"),\n        (Currency.USD, Currency.JPY): Decimal(\"150.0\"),\n        (Currency.JPY, Currency.USD): Decimal(\"0.0067\"),\n        (Currency.USD, Currency.KRW): Decimal(\"1300.0\"),\n        (Currency.KRW, Currency.USD): Decimal(\"0.00077\"),\n        (Currency.USD, Currency.GBP): Decimal(\"0.79\"),\n        (Currency.GBP, Currency.USD): Decimal(\"1.27\"),\n        (Currency.USD, Currency.BRL): Decimal(\"5.0\"),\n        (Currency.BRL, Currency.USD): Decimal(\"0.20\"),\n        (Currency.USD, Currency.CNY): Decimal(\"7.25\"),\n        (Currency.CNY, Currency.USD): Decimal(\"0.14\"),\n        (Currency.USD, Currency.HKD): Decimal(\"7.80\"),\n        (Currency.HKD, Currency.USD): Decimal(\"0.128\"),\n        (Currency.USD, Currency.MXN): Decimal(\"17.0\"),\n        (Currency.MXN, Currency.USD): Decimal(\"0.059\"),\n        (Currency.USD, Currency.ZAR): Decimal(\"18.5\"),\n        (Currency.ZAR, Currency.USD): Decimal(\"0.054\"),\n        (Currency.USD, Currency.CHF): Decimal(\"0.88\"),\n        (Currency.CHF, Currency.USD): Decimal(\"1.14\"),\n        (Currency.USD, Currency.THB): Decimal(\"35.0\"),\n        (Currency.THB, Currency.USD): Decimal(\"0.029\"),\n    }\n\n    def __init__(self, exchange_rates:dict[tuple[Currency, Currency], Decimal]={}):\n        \"\"\"Initialize with optional custom exchange rates.\n\n        Args:\n            exchange_rates: Custom rates to use. Missing pairs are filled\n                from global_exchange_rates defaults.\n        \"\"\"\n        self.exchange_rates = exchange_rates\n        for (from_currency, to_currency), rate in self.global_exchange_rates.items():\n            if (from_currency, to_currency) not in self.exchange_rates:\n                self.exchange_rates[(from_currency, to_currency)] = rate\n\n    def set_exchange_rate(self, from_currency: Currency, to_currency: Currency, rate: Decimal):\n        \"\"\"Set or override the exchange rate for a currency pair.\n\n        Args:\n            from_currency: The source currency.\n            to_currency: The target currency.\n            rate: The exchange rate to set.\n        \"\"\"\n        self.exchange_rates[(from_currency, to_currency)] = rate\n\n    def get_exchange_rate(self, from_currency: Currency, to_currency: Currency, datetime:datetime|None=None) -&gt; Decimal:\n        \"\"\"Get the fixed exchange rate between two currencies.\n\n        Falls back to USD-triangulated conversion if no direct rate exists.\n\n        Args:\n            from_currency: The source currency.\n            to_currency: The target currency.\n            datetime: Ignored; included for interface compatibility.\n\n        Returns:\n            The exchange rate as a Decimal.\n\n        Raises:\n            ValueError: If no rate is available for the currency pair.\n        \"\"\"\n        if from_currency == to_currency:\n            return Decimal(\"1.0\")\n\n        # Try direct lookup\n        if (from_currency, to_currency) in self.exchange_rates:\n            return self.exchange_rates[(from_currency, to_currency)]\n\n        # If neither currency is USD, try converting via USD\n        if from_currency != Currency.USD and to_currency != Currency.USD:\n            from_to_usd = (from_currency, Currency.USD)\n            usd_to_target = (Currency.USD, to_currency)\n\n            if from_to_usd in self.exchange_rates and usd_to_target in self.exchange_rates:\n                rate_to_usd = self.exchange_rates[from_to_usd]\n                rate_from_usd = self.exchange_rates[usd_to_target]\n                return rate_to_usd * rate_from_usd\n\n        raise ValueError(f\"Exchange rate from {from_currency} to {to_currency} not available.\")\n</code></pre>"},{"location":"reference/currency/#athena.currency.FixedExchangeRateManager.__init__","title":"<code>__init__(exchange_rates={})</code>","text":"<p>Initialize with optional custom exchange rates.</p> <p>Parameters:</p> Name Type Description Default <code>exchange_rates</code> <code>dict[tuple[Currency, Currency], Decimal]</code> <p>Custom rates to use. Missing pairs are filled from global_exchange_rates defaults.</p> <code>{}</code> Source code in <code>src/athena/currency.py</code> <pre><code>def __init__(self, exchange_rates:dict[tuple[Currency, Currency], Decimal]={}):\n    \"\"\"Initialize with optional custom exchange rates.\n\n    Args:\n        exchange_rates: Custom rates to use. Missing pairs are filled\n            from global_exchange_rates defaults.\n    \"\"\"\n    self.exchange_rates = exchange_rates\n    for (from_currency, to_currency), rate in self.global_exchange_rates.items():\n        if (from_currency, to_currency) not in self.exchange_rates:\n            self.exchange_rates[(from_currency, to_currency)] = rate\n</code></pre>"},{"location":"reference/currency/#athena.currency.FixedExchangeRateManager.set_exchange_rate","title":"<code>set_exchange_rate(from_currency, to_currency, rate)</code>","text":"<p>Set or override the exchange rate for a currency pair.</p> <p>Parameters:</p> Name Type Description Default <code>from_currency</code> <code>Currency</code> <p>The source currency.</p> required <code>to_currency</code> <code>Currency</code> <p>The target currency.</p> required <code>rate</code> <code>Decimal</code> <p>The exchange rate to set.</p> required Source code in <code>src/athena/currency.py</code> <pre><code>def set_exchange_rate(self, from_currency: Currency, to_currency: Currency, rate: Decimal):\n    \"\"\"Set or override the exchange rate for a currency pair.\n\n    Args:\n        from_currency: The source currency.\n        to_currency: The target currency.\n        rate: The exchange rate to set.\n    \"\"\"\n    self.exchange_rates[(from_currency, to_currency)] = rate\n</code></pre>"},{"location":"reference/currency/#athena.currency.FixedExchangeRateManager.get_exchange_rate","title":"<code>get_exchange_rate(from_currency, to_currency, datetime=None)</code>","text":"<p>Get the fixed exchange rate between two currencies.</p> <p>Falls back to USD-triangulated conversion if no direct rate exists.</p> <p>Parameters:</p> Name Type Description Default <code>from_currency</code> <code>Currency</code> <p>The source currency.</p> required <code>to_currency</code> <code>Currency</code> <p>The target currency.</p> required <code>datetime</code> <code>datetime | None</code> <p>Ignored; included for interface compatibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>Decimal</code> <p>The exchange rate as a Decimal.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no rate is available for the currency pair.</p> Source code in <code>src/athena/currency.py</code> <pre><code>def get_exchange_rate(self, from_currency: Currency, to_currency: Currency, datetime:datetime|None=None) -&gt; Decimal:\n    \"\"\"Get the fixed exchange rate between two currencies.\n\n    Falls back to USD-triangulated conversion if no direct rate exists.\n\n    Args:\n        from_currency: The source currency.\n        to_currency: The target currency.\n        datetime: Ignored; included for interface compatibility.\n\n    Returns:\n        The exchange rate as a Decimal.\n\n    Raises:\n        ValueError: If no rate is available for the currency pair.\n    \"\"\"\n    if from_currency == to_currency:\n        return Decimal(\"1.0\")\n\n    # Try direct lookup\n    if (from_currency, to_currency) in self.exchange_rates:\n        return self.exchange_rates[(from_currency, to_currency)]\n\n    # If neither currency is USD, try converting via USD\n    if from_currency != Currency.USD and to_currency != Currency.USD:\n        from_to_usd = (from_currency, Currency.USD)\n        usd_to_target = (Currency.USD, to_currency)\n\n        if from_to_usd in self.exchange_rates and usd_to_target in self.exchange_rates:\n            rate_to_usd = self.exchange_rates[from_to_usd]\n            rate_from_usd = self.exchange_rates[usd_to_target]\n            return rate_to_usd * rate_from_usd\n\n    raise ValueError(f\"Exchange rate from {from_currency} to {to_currency} not available.\")\n</code></pre>"},{"location":"reference/currency/#athena.currency.FederalReserveExchangeRateManager","title":"<code>FederalReserveExchangeRateManager</code>","text":"<p>               Bases: <code>ExchangeRateManager</code></p> <p>Exchange rate manager that fetches historical rates from the Federal Reserve H.10 data.</p> <p>Downloads daily exchange rate CSV data from the Fed's website and caches it locally. Supports lookback of up to 14 days for missing dates.</p> Source code in <code>src/athena/currency.py</code> <pre><code>class FederalReserveExchangeRateManager(ExchangeRateManager):\n    \"\"\"Exchange rate manager that fetches historical rates from the Federal Reserve H.10 data.\n\n    Downloads daily exchange rate CSV data from the Fed's website and caches\n    it locally. Supports lookback of up to 14 days for missing dates.\n    \"\"\"\n\n    # Mapping from Fed's currency codes to our Currency enum\n    FED_CURRENCY_MAP = {\n        \"EU\": Currency.EUR,\n        \"CA\": Currency.CAD,\n        \"SI\": Currency.SGD,\n        \"AL\": Currency.AUD,\n        \"JA\": Currency.JPY,\n        \"KO\": Currency.KRW,\n        \"TA\": Currency.TWD,\n        \"UK\": Currency.GBP,\n        \"BZ\": Currency.BRL,\n        \"CH\": Currency.CNY,\n        \"HK\": Currency.HKD,\n        \"MX\": Currency.MXN,\n        \"SF\": Currency.ZAR,\n        \"SZ\": Currency.CHF,\n        \"TH\": Currency.THB,\n    }\n\n    def __init__(self, min_datetime:datetime|None = None, max_datetime:datetime|None = None, use_cache: bool = False):\n        \"\"\"Initialize by fetching exchange rate data from the Federal Reserve.\n\n        Args:\n            min_datetime: Start of the date range. Defaults to 2020-01-01.\n            max_datetime: End of the date range. Defaults to now.\n            use_cache: If True, use disk-cached CSV data when available and fresh.\n        \"\"\"\n        if min_datetime is None:\n            min_datetime = datetime(2020, 1, 1)\n\n        if max_datetime is None:\n            max_datetime = datetime.now()\n\n        super().__init__(min_datetime, max_datetime)\n\n        # Format dates as mm/dd/yyyy for the Fed API\n        from_date = min_datetime.strftime(\"%m/%d/%Y\")\n        to_date = max_datetime.strftime(\"%m/%d/%Y\")\n\n        base_url = (\n            f\"https://www.federalreserve.gov/datadownload/Output.aspx?\"\n            f\"rel=H10&amp;series=1f5e3a7e4b72dcddfd7ca4c7c6a8cd55&amp;lastobs=&amp;\"\n            f\"from={from_date}&amp;to={to_date}&amp;filetype=csv&amp;label=include&amp;layout=seriescolumn\"\n        )\n\n        # Dictionary to store exchange rates: {(date_str, currency_pair_str): Decimal}\n        # e.g., {(\"2023-01-03\", \"USD-&gt;CAD\"): Decimal(\"1.3664\")}\n        self.exchange_rates: dict[tuple[str, str], Decimal] = {}\n\n        # Generate cache file path based on date range (in project's .cache folder)\n        cache_key = hashlib.md5(f\"{from_date}_{to_date}\".encode()).hexdigest()[:12]\n        self._cache_path = Path.cwd() / \".cache\" / \"fed_exchange_rates\" / f\"fed_rates_{cache_key}.csv\"\n\n        self._fetch_and_parse_data(base_url, use_cache)\n\n    def _is_cache_valid(self) -&gt; bool:\n        \"\"\"Check if cache file exists and was modified today.\n\n        Returns:\n            True if the cache file exists and was last modified today.\n        \"\"\"\n        if not self._cache_path.exists():\n            return False\n        mtime = datetime.fromtimestamp(self._cache_path.stat().st_mtime)\n        return mtime.date() == datetime.now().date()\n\n    def _fetch_and_parse_data(self, url: str, use_cache: bool) -&gt; None:\n        \"\"\"Fetch CSV data from the Federal Reserve and parse it into exchange rates.\n\n        Args:\n            url: The Federal Reserve H.10 CSV download URL.\n            use_cache: If True, read from disk cache when valid and write\n                fetched data back to disk.\n        \"\"\"\n        data: str\n\n        if use_cache and self._is_cache_valid():\n            data = self._cache_path.read_text(encoding='utf-8')\n        else:\n            headers = {\n                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',\n                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n                'Accept-Language': 'en-US,en;q=0.5',\n                'Referer': 'https://www.federalreserve.gov/releases/h10/hist/default.htm',\n            }\n            req = urllib.request.Request(url, headers=headers)\n            with urllib.request.urlopen(req) as response:\n                data = response.read().decode('utf-8')\n            if use_cache:\n                self._cache_path.parent.mkdir(parents=True, exist_ok=True)\n                self._cache_path.write_text(data, encoding='utf-8')\n\n        reader = csv.reader(io.StringIO(data))\n        rows = list(reader)\n\n        # Row 4 (index 4) contains the unique identifiers that tell us the direction\n        # e.g., \"H10/H10/RXI$US_N.B.EU\" or \"H10/H10/RXI_N.B.CA\"\n        identifier_row = rows[4]\n\n        # Row 5 (index 5) contains the column headers for the time series\n        # e.g., \"Time Period\", \"RXI$US_N.B.EU\", \"RXI_N.B.CA\", \"RXI_N.B.SI\"\n\n        # Parse column metadata to determine currency pairs\n        # Column 0 is \"Time Period\", columns 1+ are currencies\n        column_pairs: list[str | None] = []  # Will hold currency pair strings like \"USD-&gt;CAD\"\n\n        for col_idx in range(1, len(identifier_row)):\n            identifier = identifier_row[col_idx].strip().strip('\"')\n            # Extract the series code, e.g., \"RXI$US_N.B.EU\" from \"H10/H10/RXI$US_N.B.EU\"\n            series_code = identifier.split(\"/\")[-1] if \"/\" in identifier else identifier\n\n            # Determine currency and direction from series code\n            # RXI$US_N.B.XX means USD per 1 XX (so XX -&gt; USD)\n            # RXI_N.B.XX means XX per 1 USD (so USD -&gt; XX)\n            if \"$US\" in series_code:\n                # USD per foreign currency: foreign -&gt; USD\n                # Extract currency code (last 2 chars before any trailing chars)\n                currency_code = series_code.split(\".\")[-1]\n                foreign_currency = self.FED_CURRENCY_MAP.get(currency_code)\n                if foreign_currency:\n                    column_pairs.append(f\"{foreign_currency.value}-&gt;USD\")\n                else:\n                    column_pairs.append(None)\n            else:\n                # Foreign currency per USD: USD -&gt; foreign\n                currency_code = series_code.split(\".\")[-1]\n                foreign_currency = self.FED_CURRENCY_MAP.get(currency_code)\n                if foreign_currency:\n                    column_pairs.append(f\"USD-&gt;{foreign_currency.value}\")\n                else:\n                    column_pairs.append(None)\n\n        # Data rows start at index 6\n        for row in rows[6:]:\n            if len(row) &lt; 2:\n                continue\n\n            date_str = row[0].strip()\n            # Validate it looks like a date (yyyy-mm-dd)\n            if not date_str or len(date_str) != 10 or date_str[4] != '-':\n                continue\n\n            for col_idx in range(1, len(row)):\n                if col_idx - 1 &gt;= len(column_pairs):\n                    continue\n\n                pair = column_pairs[col_idx - 1]\n                if pair is None:\n                    continue\n\n                value_str = row[col_idx].strip()\n                # Skip \"ND\" (No Data) entries\n                if value_str == \"ND\" or not value_str:\n                    continue\n\n                try:\n                    rate = Decimal(value_str)\n                    self.exchange_rates[(date_str, pair)] = rate\n                except (ValueError, ArithmeticError):\n                    continue\n\n    def _get_rate_for_pair(self, pair: str, datetime: datetime) -&gt; Decimal | None:\n        \"\"\"Try to get exchange rate for a pair, looking back up to 14 days.\n\n        Args:\n            pair: Currency pair string in \"XXX-&gt;YYY\" format.\n            datetime: The target date to start the lookback from.\n\n        Returns:\n            The exchange rate as a Decimal, or None if no rate is found\n            within the 14-day lookback window.\n        \"\"\"\n        for days_back in range(15):\n            lookup_date = datetime - dt_module.timedelta(days=days_back)\n            date_str = lookup_date.strftime(\"%Y-%m-%d\")\n            if (date_str, pair) in self.exchange_rates:\n                return self.exchange_rates[(date_str, pair)]\n        return None\n\n    def get_exchange_rate(self, from_currency: Currency, to_currency: Currency, datetime: datetime | None = None) -&gt; Decimal:\n        \"\"\"Get exchange rate for a currency pair on a specific date.\n\n        If no data is available for the requested date, looks back up to 14 days\n        to handle weekends, bank holidays, and publication delays.\n        If neither currency is USD, converts via USD (e.g., HKD -&gt; USD -&gt; CAD).\n\n        Args:\n            from_currency: The source currency.\n            to_currency: The target currency.\n            datetime: The date for the rate lookup. Defaults to now.\n\n        Returns:\n            The exchange rate as a Decimal.\n\n        Raises:\n            ValueError: If no rate is available for the pair within the\n                14-day lookback window.\n        \"\"\"\n        if from_currency == to_currency:\n            return Decimal(\"1.0\")\n\n        if datetime is None:\n            datetime = dt_module.datetime.now()\n\n        pair = f\"{from_currency.value}-&gt;{to_currency.value}\"\n        inverse_pair = f\"{to_currency.value}-&gt;{from_currency.value}\"\n\n        # Try direct lookup\n        rate = self._get_rate_for_pair(pair, datetime)\n        if rate is not None:\n            return rate\n\n        # Try inverse lookup\n        inverse_rate = self._get_rate_for_pair(inverse_pair, datetime)\n        if inverse_rate is not None:\n            return Decimal(\"1\") / inverse_rate\n\n        # If neither currency is USD, try converting via USD\n        if from_currency != Currency.USD and to_currency != Currency.USD:\n            from_to_usd_pair = f\"{from_currency.value}-&gt;USD\"\n            usd_to_target_pair = f\"USD-&gt;{to_currency.value}\"\n\n            rate_to_usd = self._get_rate_for_pair(from_to_usd_pair, datetime)\n            if rate_to_usd is None:\n                # Try inverse: USD -&gt; from_currency\n                inverse_from_usd = self._get_rate_for_pair(f\"USD-&gt;{from_currency.value}\", datetime)\n                if inverse_from_usd is not None:\n                    rate_to_usd = Decimal(\"1\") / inverse_from_usd\n\n            rate_from_usd = self._get_rate_for_pair(usd_to_target_pair, datetime)\n            if rate_from_usd is None:\n                # Try inverse: to_currency -&gt; USD\n                inverse_to_usd = self._get_rate_for_pair(f\"{to_currency.value}-&gt;USD\", datetime)\n                if inverse_to_usd is not None:\n                    rate_from_usd = Decimal(\"1\") / inverse_to_usd\n\n            if rate_to_usd is not None and rate_from_usd is not None:\n                return rate_to_usd * rate_from_usd\n\n        raise ValueError(\n            f\"Exchange rate from {from_currency.value} to {to_currency.value} \"\n            f\"not available for date {datetime.strftime('%Y-%m-%d')} or the previous 14 days.\"\n        )\n</code></pre>"},{"location":"reference/currency/#athena.currency.FederalReserveExchangeRateManager.__init__","title":"<code>__init__(min_datetime=None, max_datetime=None, use_cache=False)</code>","text":"<p>Initialize by fetching exchange rate data from the Federal Reserve.</p> <p>Parameters:</p> Name Type Description Default <code>min_datetime</code> <code>datetime | None</code> <p>Start of the date range. Defaults to 2020-01-01.</p> <code>None</code> <code>max_datetime</code> <code>datetime | None</code> <p>End of the date range. Defaults to now.</p> <code>None</code> <code>use_cache</code> <code>bool</code> <p>If True, use disk-cached CSV data when available and fresh.</p> <code>False</code> Source code in <code>src/athena/currency.py</code> <pre><code>def __init__(self, min_datetime:datetime|None = None, max_datetime:datetime|None = None, use_cache: bool = False):\n    \"\"\"Initialize by fetching exchange rate data from the Federal Reserve.\n\n    Args:\n        min_datetime: Start of the date range. Defaults to 2020-01-01.\n        max_datetime: End of the date range. Defaults to now.\n        use_cache: If True, use disk-cached CSV data when available and fresh.\n    \"\"\"\n    if min_datetime is None:\n        min_datetime = datetime(2020, 1, 1)\n\n    if max_datetime is None:\n        max_datetime = datetime.now()\n\n    super().__init__(min_datetime, max_datetime)\n\n    # Format dates as mm/dd/yyyy for the Fed API\n    from_date = min_datetime.strftime(\"%m/%d/%Y\")\n    to_date = max_datetime.strftime(\"%m/%d/%Y\")\n\n    base_url = (\n        f\"https://www.federalreserve.gov/datadownload/Output.aspx?\"\n        f\"rel=H10&amp;series=1f5e3a7e4b72dcddfd7ca4c7c6a8cd55&amp;lastobs=&amp;\"\n        f\"from={from_date}&amp;to={to_date}&amp;filetype=csv&amp;label=include&amp;layout=seriescolumn\"\n    )\n\n    # Dictionary to store exchange rates: {(date_str, currency_pair_str): Decimal}\n    # e.g., {(\"2023-01-03\", \"USD-&gt;CAD\"): Decimal(\"1.3664\")}\n    self.exchange_rates: dict[tuple[str, str], Decimal] = {}\n\n    # Generate cache file path based on date range (in project's .cache folder)\n    cache_key = hashlib.md5(f\"{from_date}_{to_date}\".encode()).hexdigest()[:12]\n    self._cache_path = Path.cwd() / \".cache\" / \"fed_exchange_rates\" / f\"fed_rates_{cache_key}.csv\"\n\n    self._fetch_and_parse_data(base_url, use_cache)\n</code></pre>"},{"location":"reference/currency/#athena.currency.FederalReserveExchangeRateManager.get_exchange_rate","title":"<code>get_exchange_rate(from_currency, to_currency, datetime=None)</code>","text":"<p>Get exchange rate for a currency pair on a specific date.</p> <p>If no data is available for the requested date, looks back up to 14 days to handle weekends, bank holidays, and publication delays. If neither currency is USD, converts via USD (e.g., HKD -&gt; USD -&gt; CAD).</p> <p>Parameters:</p> Name Type Description Default <code>from_currency</code> <code>Currency</code> <p>The source currency.</p> required <code>to_currency</code> <code>Currency</code> <p>The target currency.</p> required <code>datetime</code> <code>datetime | None</code> <p>The date for the rate lookup. Defaults to now.</p> <code>None</code> <p>Returns:</p> Type Description <code>Decimal</code> <p>The exchange rate as a Decimal.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no rate is available for the pair within the 14-day lookback window.</p> Source code in <code>src/athena/currency.py</code> <pre><code>def get_exchange_rate(self, from_currency: Currency, to_currency: Currency, datetime: datetime | None = None) -&gt; Decimal:\n    \"\"\"Get exchange rate for a currency pair on a specific date.\n\n    If no data is available for the requested date, looks back up to 14 days\n    to handle weekends, bank holidays, and publication delays.\n    If neither currency is USD, converts via USD (e.g., HKD -&gt; USD -&gt; CAD).\n\n    Args:\n        from_currency: The source currency.\n        to_currency: The target currency.\n        datetime: The date for the rate lookup. Defaults to now.\n\n    Returns:\n        The exchange rate as a Decimal.\n\n    Raises:\n        ValueError: If no rate is available for the pair within the\n            14-day lookback window.\n    \"\"\"\n    if from_currency == to_currency:\n        return Decimal(\"1.0\")\n\n    if datetime is None:\n        datetime = dt_module.datetime.now()\n\n    pair = f\"{from_currency.value}-&gt;{to_currency.value}\"\n    inverse_pair = f\"{to_currency.value}-&gt;{from_currency.value}\"\n\n    # Try direct lookup\n    rate = self._get_rate_for_pair(pair, datetime)\n    if rate is not None:\n        return rate\n\n    # Try inverse lookup\n    inverse_rate = self._get_rate_for_pair(inverse_pair, datetime)\n    if inverse_rate is not None:\n        return Decimal(\"1\") / inverse_rate\n\n    # If neither currency is USD, try converting via USD\n    if from_currency != Currency.USD and to_currency != Currency.USD:\n        from_to_usd_pair = f\"{from_currency.value}-&gt;USD\"\n        usd_to_target_pair = f\"USD-&gt;{to_currency.value}\"\n\n        rate_to_usd = self._get_rate_for_pair(from_to_usd_pair, datetime)\n        if rate_to_usd is None:\n            # Try inverse: USD -&gt; from_currency\n            inverse_from_usd = self._get_rate_for_pair(f\"USD-&gt;{from_currency.value}\", datetime)\n            if inverse_from_usd is not None:\n                rate_to_usd = Decimal(\"1\") / inverse_from_usd\n\n        rate_from_usd = self._get_rate_for_pair(usd_to_target_pair, datetime)\n        if rate_from_usd is None:\n            # Try inverse: to_currency -&gt; USD\n            inverse_to_usd = self._get_rate_for_pair(f\"{to_currency.value}-&gt;USD\", datetime)\n            if inverse_to_usd is not None:\n                rate_from_usd = Decimal(\"1\") / inverse_to_usd\n\n        if rate_to_usd is not None and rate_from_usd is not None:\n            return rate_to_usd * rate_from_usd\n\n    raise ValueError(\n        f\"Exchange rate from {from_currency.value} to {to_currency.value} \"\n        f\"not available for date {datetime.strftime('%Y-%m-%d')} or the previous 14 days.\"\n    )\n</code></pre>"},{"location":"reference/dashboard/","title":"dashboard","text":""},{"location":"reference/dashboard/#athena.dashboard","title":"<code>athena.dashboard</code>","text":""},{"location":"reference/dashboard/#athena.dashboard.generate_dashboard","title":"<code>generate_dashboard(portfolio, target_currency, annual_risk_free_rate, start_date=None, end_date=None, title='Portfolio Dashboard', periods_in_year=365)</code>","text":"<p>Generate an HTML dashboard for a portfolio.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to display values in.</p> required <code>annual_risk_free_rate</code> <code>float</code> <p>Annual nominal risk-free rate for Sharpe calculation.</p> required <code>start_date</code> <code>datetime | None</code> <p>Start date for the analysis period.</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>End date for the analysis period.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title to display on the dashboard.</p> <code>'Portfolio Dashboard'</code> <code>periods_in_year</code> <code>int</code> <p>Trading periods in a year (365 for daily).</p> <code>365</code> <p>Returns:</p> Type Description <code>str</code> <p>HTML string of the complete dashboard.</p> Source code in <code>src/athena/dashboard/generator.py</code> <pre><code>def generate_dashboard(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    annual_risk_free_rate: float,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    title: str = \"Portfolio Dashboard\",\n    periods_in_year: int = 365,\n) -&gt; str:\n    \"\"\"\n    Generate an HTML dashboard for a portfolio.\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to display values in.\n        annual_risk_free_rate: Annual nominal risk-free rate for Sharpe calculation.\n        start_date: Start date for the analysis period.\n        end_date: End date for the analysis period.\n        title: Title to display on the dashboard.\n        periods_in_year: Trading periods in a year (365 for daily).\n\n    Returns:\n        HTML string of the complete dashboard.\n    \"\"\"\n    # Get portfolio values over time\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if not portfolio_values:\n        raise ValueError(\"No portfolio values available for the given date range.\")\n\n    sorted_dates = sorted(portfolio_values.keys())\n\n    # Calculate metrics\n    start_value = portfolio_values[sorted_dates[0]]\n    end_value = portfolio_values[sorted_dates[-1]]\n    total_return = float((end_value - start_value) / start_value * 100) if start_value != 0 else 0\n\n    # Calculate Sharpe ratio\n    try:\n        daily_sharpe, annual_sharpe = calculate_sharpe_ratio_cumulative(\n            portfolio,\n            target_currency,\n            annual_risk_free_rate,\n            start_date,\n            end_date,\n            periods_in_year\n        )\n    except ValueError:\n        daily_sharpe, annual_sharpe = None, None\n\n    # Calculate daily returns for chart\n    daily_returns = calculate_daily_returns(portfolio_values)\n\n    # Calculate cumulative Sharpe over time for chart\n    sharpe_by_day = calculate_sharpe_ratio_by_day_cumulative(\n        portfolio,\n        target_currency,\n        annual_risk_free_rate,\n        start_date,\n        end_date,\n        periods_in_year\n    )\n\n    # Calculate drawdown periods\n    drawdown_periods = calculate_drawdown_periods(portfolio_values)\n\n    # Prepare chart data\n    value_chart_data = {\n        \"labels\": [d.strftime(\"%Y-%m-%d\") for d in sorted_dates],\n        \"values\": [float(portfolio_values[d]) for d in sorted_dates]\n    }\n\n    returns_chart_data = {\n        \"labels\": [d.strftime(\"%Y-%m-%d\") for d in sorted(daily_returns.keys())],\n        \"values\": [daily_returns[d] * 100 for d in sorted(daily_returns.keys())]  # Convert to percentage\n    }\n\n    sharpe_dates = sorted(sharpe_by_day.keys())\n    sharpe_chart_data = {\n        \"labels\": [d.strftime(\"%Y-%m-%d\") for d in sharpe_dates],\n        \"values\": [sharpe_by_day[d][1] for d in sharpe_dates]  # Annual Sharpe\n    }\n\n    # Prepare template context\n    context = {\n        \"title\": title,\n        \"currency\": target_currency.value,\n        \"start_date\": sorted_dates[0].strftime(\"%Y-%m-%d\"),\n        \"end_date\": sorted_dates[-1].strftime(\"%Y-%m-%d\"),\n        \"start_value\": float(start_value),\n        \"end_value\": float(end_value),\n        \"total_return\": total_return,\n        \"daily_sharpe\": daily_sharpe,\n        \"annual_sharpe\": annual_sharpe,\n        \"risk_free_rate\": annual_risk_free_rate * 100,\n        # Formatted values for display\n        \"start_value_formatted\": f\"{float(start_value):,.2f}\",\n        \"end_value_formatted\": f\"{float(end_value):,.2f}\",\n        \"total_return_formatted\": f\"{total_return:.2f}\",\n        \"risk_free_rate_formatted\": f\"{annual_risk_free_rate * 100:.2f}\",\n        \"annual_sharpe_formatted\": f\"{annual_sharpe:.2f}\" if annual_sharpe is not None else \"N/A\",\n        # Chart data\n        \"value_chart_data\": json.dumps(value_chart_data),\n        \"returns_chart_data\": json.dumps(returns_chart_data),\n        \"sharpe_chart_data\": json.dumps(sharpe_chart_data),\n        \"drawdown_periods\": json.dumps(drawdown_periods),\n    }\n\n    # Render template\n    env = Environment(loader=FileSystemLoader(TEMPLATES_DIR))\n    template = env.get_template(\"dashboard.html\")\n\n    return template.render(**context)\n</code></pre>"},{"location":"reference/metrics/","title":"metrics","text":""},{"location":"reference/metrics/#athena.metrics","title":"<code>athena.metrics</code>","text":"<p>Portfolio risk and performance metrics.</p> <p>Provides functions for calculating Sharpe ratio, Sortino ratio, maximum drawdown, Value at Risk, volatility, win rate, and alpha/beta against market benchmarks.  Sub-modules for options-implied analytics (forward curves, theta decay) are available but not re-exported here.</p>"},{"location":"reference/metrics/#athena.metrics.AlphaBetaResult","title":"<code>AlphaBetaResult</code>  <code>dataclass</code>","text":"<p>Result container for alpha/beta calculations.</p> Source code in <code>src/athena/metrics/alpha_beta.py</code> <pre><code>@dataclass\nclass AlphaBetaResult:\n    \"\"\"Result container for alpha/beta calculations.\"\"\"\n    alpha: float            # Jensen's alpha (daily)\n    alpha_annualized: float # Annualized alpha\n    beta: float             # Market beta\n    r_squared: float        # Coefficient of determination (0-1)\n    correlation: float      # Correlation with benchmark\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.ClosedPosition","title":"<code>ClosedPosition</code>  <code>dataclass</code>","text":"<p>Represents a closed position with its realized gain/loss.</p> Source code in <code>src/athena/metrics/win_rate.py</code> <pre><code>@dataclass\nclass ClosedPosition:\n    \"\"\"Represents a closed position with its realized gain/loss.\"\"\"\n    symbol: str\n    quantity: Decimal\n    buy_price: Decimal\n    sell_price: Decimal\n    buy_date: datetime\n    sell_date: datetime\n    currency: Currency\n    realized_gain_loss: Decimal\n    realized_gain_loss_percent: Decimal\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.WinRateResult","title":"<code>WinRateResult</code>  <code>dataclass</code>","text":"<p>Result of a win rate calculation.</p> Source code in <code>src/athena/metrics/win_rate.py</code> <pre><code>@dataclass\nclass WinRateResult:\n    \"\"\"Result of a win rate calculation.\"\"\"\n    win_rate: float\n    total_positions: int\n    winning_positions: int\n    losing_positions: int\n    breakeven_positions: int\n    total_gain_loss: Decimal\n    average_win: Decimal | None\n    average_loss: Decimal | None\n    win_loss_ratio: float | None\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.align_strategy_with_benchmark","title":"<code>align_strategy_with_benchmark(strategy_returns, benchmark_returns, rf_manager=None, trading_days_per_year=252)</code>","text":"<p>Align strategy returns with benchmark returns on trading days.</p> <p>Only includes dates where both strategy and benchmark have data. Optionally includes risk-free rates for each date.</p> <p>Parameters:</p> Name Type Description Default <code>strategy_returns</code> <code>dict[datetime, float]</code> <p>Dictionary mapping dates to strategy returns.</p> required <code>benchmark_returns</code> <code>dict[datetime, float]</code> <p>Dictionary mapping dates to benchmark returns.</p> required <code>rf_manager</code> <code>RiskFreeRateManager | None</code> <p>Optional risk-free rate manager. If None, uses 0.0 for all dates.</p> <code>None</code> <code>trading_days_per_year</code> <code>int</code> <p>Number of trading days per year for daily rate calc.</p> <code>252</code> <p>Returns:</p> Type Description <code>Tuple[list[float], list[float], list[float], list[datetime]]</code> <p>Tuple of (aligned_strategy_returns, aligned_benchmark_returns,       aligned_rf_rates, aligned_dates).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no overlapping dates are found.</p> Source code in <code>src/athena/metrics/alpha_beta.py</code> <pre><code>def align_strategy_with_benchmark(\n    strategy_returns: dict[datetime, float],\n    benchmark_returns: dict[datetime, float],\n    rf_manager: RiskFreeRateManager | None = None,\n    trading_days_per_year: int = 252\n) -&gt; Tuple[list[float], list[float], list[float], list[datetime]]:\n    \"\"\"\n    Align strategy returns with benchmark returns on trading days.\n\n    Only includes dates where both strategy and benchmark have data.\n    Optionally includes risk-free rates for each date.\n\n    Args:\n        strategy_returns: Dictionary mapping dates to strategy returns.\n        benchmark_returns: Dictionary mapping dates to benchmark returns.\n        rf_manager: Optional risk-free rate manager. If None, uses 0.0 for all dates.\n        trading_days_per_year: Number of trading days per year for daily rate calc.\n\n    Returns:\n        Tuple of (aligned_strategy_returns, aligned_benchmark_returns,\n                  aligned_rf_rates, aligned_dates).\n\n    Raises:\n        ValueError: If no overlapping dates are found.\n    \"\"\"\n    # Find overlapping dates\n    strategy_dates = set(strategy_returns.keys())\n    benchmark_dates = set(benchmark_returns.keys())\n    common_dates = strategy_dates &amp; benchmark_dates\n\n    if not common_dates:\n        raise ValueError(\n            \"No overlapping dates between strategy and benchmark returns.\"\n        )\n\n    aligned_strategy: list[float] = []\n    aligned_benchmark: list[float] = []\n    aligned_rf: list[float] = []\n    aligned_dates: list[datetime] = []\n\n    for dt in sorted(common_dates):\n        dt_date = dt.date()\n\n        # Skip weekends\n        if dt_date.weekday() &gt;= 5:\n            continue\n\n        # Get risk-free rate for this date\n        if rf_manager is not None:\n            try:\n                annual_rate = rf_manager.get_rate(dt_date)\n                daily_rf = float(annual_rate) / trading_days_per_year\n            except ValueError:\n                # No risk-free rate available, skip this date\n                continue\n        else:\n            daily_rf = 0.0\n\n        aligned_strategy.append(strategy_returns[dt])\n        aligned_benchmark.append(benchmark_returns[dt])\n        aligned_rf.append(daily_rf)\n        aligned_dates.append(dt)\n\n    if len(aligned_strategy) == 0:\n        raise ValueError(\n            \"No overlapping dates after filtering weekends and risk-free rate availability.\"\n        )\n\n    return aligned_strategy, aligned_benchmark, aligned_rf, aligned_dates\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_alpha_beta","title":"<code>calculate_alpha_beta(strategy_returns, benchmark_returns, risk_free_rates=None, trading_days_per_year=252)</code>","text":"<p>Calculate alpha and beta using OLS regression.</p> <p>Uses the CAPM model: excess_strategy = alpha + beta * excess_benchmark</p> <p>Parameters:</p> Name Type Description Default <code>strategy_returns</code> <code>list[float]</code> <p>List of daily strategy returns.</p> required <code>benchmark_returns</code> <code>list[float]</code> <p>List of daily benchmark returns (same length).</p> required <code>risk_free_rates</code> <code>list[float] | None</code> <p>Optional list of daily risk-free rates.              If None, uses 0.0 (raw returns instead of excess).</p> <code>None</code> <code>trading_days_per_year</code> <code>int</code> <p>Trading days per year for annualization (default 252).</p> <code>252</code> <p>Returns:</p> Type Description <code>AlphaBetaResult</code> <p>AlphaBetaResult with alpha, beta, r_squared, and correlation.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If inputs have different lengths or fewer than 2 observations.</p> Source code in <code>src/athena/metrics/alpha_beta.py</code> <pre><code>def calculate_alpha_beta(\n    strategy_returns: list[float],\n    benchmark_returns: list[float],\n    risk_free_rates: list[float] | None = None,\n    trading_days_per_year: int = 252\n) -&gt; AlphaBetaResult:\n    \"\"\"\n    Calculate alpha and beta using OLS regression.\n\n    Uses the CAPM model: excess_strategy = alpha + beta * excess_benchmark\n\n    Args:\n        strategy_returns: List of daily strategy returns.\n        benchmark_returns: List of daily benchmark returns (same length).\n        risk_free_rates: Optional list of daily risk-free rates.\n                         If None, uses 0.0 (raw returns instead of excess).\n        trading_days_per_year: Trading days per year for annualization (default 252).\n\n    Returns:\n        AlphaBetaResult with alpha, beta, r_squared, and correlation.\n\n    Raises:\n        ValueError: If inputs have different lengths or fewer than 2 observations.\n    \"\"\"\n    if len(strategy_returns) != len(benchmark_returns):\n        raise ValueError(\n            f\"Strategy and benchmark returns must have same length. \"\n            f\"Got {len(strategy_returns)} and {len(benchmark_returns)}.\"\n        )\n\n    if len(strategy_returns) &lt; 2:\n        raise ValueError(\"Need at least two return observations.\")\n\n    strategy_arr = np.array(strategy_returns, dtype=float)\n    benchmark_arr = np.array(benchmark_returns, dtype=float)\n\n    # Calculate excess returns if risk-free rates provided\n    if risk_free_rates is not None:\n        if len(risk_free_rates) != len(strategy_returns):\n            raise ValueError(\n                f\"Risk-free rates must have same length as returns. \"\n                f\"Got {len(risk_free_rates)} rates and {len(strategy_returns)} returns.\"\n            )\n        rf_arr = np.array(risk_free_rates, dtype=float)\n        excess_strategy = strategy_arr - rf_arr\n        excess_benchmark = benchmark_arr - rf_arr\n    else:\n        excess_strategy = strategy_arr\n        excess_benchmark = benchmark_arr\n\n    # Perform linear regression: excess_strategy = alpha + beta * excess_benchmark\n    slope, intercept, r_value, _, _ = stats.linregress(excess_benchmark, excess_strategy)\n\n    beta = float(slope)\n    alpha_daily = float(intercept)\n    r_squared = float(r_value ** 2)\n    correlation = float(r_value)\n\n    # Annualize alpha (compound daily alpha over trading days)\n    # For small daily returns, this approximates: alpha_annual \u2248 alpha_daily * trading_days\n    alpha_annualized = alpha_daily * trading_days_per_year\n\n    return AlphaBetaResult(\n        alpha=alpha_daily,\n        alpha_annualized=alpha_annualized,\n        beta=beta,\n        r_squared=r_squared,\n        correlation=correlation\n    )\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_alpha_beta_by_day_cumulative","title":"<code>calculate_alpha_beta_by_day_cumulative(portfolio, target_currency, benchmark_ticker=BENCHMARK_SP500, rf_manager=None, start_date=None, end_date=None, trading_days_per_year=252, min_observations=20, price_manager=None)</code>","text":"<p>Calculate cumulative alpha/beta for each trading day in a date range.</p> <p>For each trading day, calculates alpha/beta using all returns from start_date up to that day (cumulative/expanding window).</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>benchmark_ticker</code> <code>str</code> <p>Yahoo Finance ticker for benchmark (default: ^GSPC).</p> <code>BENCHMARK_SP500</code> <code>rf_manager</code> <code>RiskFreeRateManager | None</code> <p>Risk-free rate manager. If None, uses FRED DTB3.</p> <code>None</code> <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).</p> <code>None</code> <code>trading_days_per_year</code> <code>int</code> <p>Trading days per year for annualization (default 252).</p> <code>252</code> <code>min_observations</code> <code>int</code> <p>Minimum observations before calculating (default 20).</p> <code>20</code> <code>price_manager</code> <code>PricingDataManager | None</code> <p>PricingDataManager for portfolio valuation.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[datetime, AlphaBetaResult]</code> <p>Dictionary mapping each trading day to AlphaBetaResult.</p> <code>dict[datetime, AlphaBetaResult]</code> <p>Days with insufficient observations are excluded.</p> Source code in <code>src/athena/metrics/alpha_beta.py</code> <pre><code>def calculate_alpha_beta_by_day_cumulative(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    benchmark_ticker: str = BENCHMARK_SP500,\n    rf_manager: RiskFreeRateManager | None = None,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    trading_days_per_year: int = 252,\n    min_observations: int = 20,\n    price_manager: PricingDataManager | None = None\n) -&gt; dict[datetime, AlphaBetaResult]:\n    \"\"\"\n    Calculate cumulative alpha/beta for each trading day in a date range.\n\n    For each trading day, calculates alpha/beta using all returns from\n    start_date up to that day (cumulative/expanding window).\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        benchmark_ticker: Yahoo Finance ticker for benchmark (default: ^GSPC).\n        rf_manager: Risk-free rate manager. If None, uses FRED DTB3.\n        start_date: The start date for the calculation (inclusive).\n        end_date: The end date for the calculation (inclusive).\n        trading_days_per_year: Trading days per year for annualization (default 252).\n        min_observations: Minimum observations before calculating (default 20).\n        price_manager: PricingDataManager for portfolio valuation.\n\n    Returns:\n        Dictionary mapping each trading day to AlphaBetaResult.\n        Days with insufficient observations are excluded.\n    \"\"\"\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; 2:\n        return {}\n\n    # Calculate strategy daily returns\n    strategy_returns = calculate_daily_returns(portfolio_values)\n\n    if len(strategy_returns) &lt; min_observations:\n        return {}\n\n    # Determine date range\n    return_dates = sorted(strategy_returns.keys())\n    min_dt = return_dates[0].date()\n    max_dt = return_dates[-1].date()\n\n    # Fetch benchmark returns\n    benchmark_returns = fetch_benchmark_returns(benchmark_ticker, min_dt, max_dt)\n\n    # Create default risk-free manager if not provided\n    if rf_manager is None:\n        rf_manager = _get_default_risk_free_manager(min_dt, max_dt)\n\n    # Align returns\n    aligned_strategy, aligned_benchmark, aligned_rf, aligned_dates = align_strategy_with_benchmark(\n        strategy_returns,\n        benchmark_returns,\n        rf_manager,\n        trading_days_per_year\n    )\n\n    if len(aligned_strategy) &lt; min_observations:\n        return {}\n\n    # Calculate cumulative alpha/beta for each trading day\n    result: dict[datetime, AlphaBetaResult] = {}\n    cumulative_strategy: list[float] = []\n    cumulative_benchmark: list[float] = []\n    cumulative_rf: list[float] = []\n\n    for i, dt in enumerate(aligned_dates):\n        cumulative_strategy.append(aligned_strategy[i])\n        cumulative_benchmark.append(aligned_benchmark[i])\n        cumulative_rf.append(aligned_rf[i])\n\n        if len(cumulative_strategy) &lt; min_observations:\n            continue\n\n        try:\n            ab_result = calculate_alpha_beta(\n                cumulative_strategy,\n                cumulative_benchmark,\n                cumulative_rf,\n                trading_days_per_year\n            )\n            result[dt] = ab_result\n        except ValueError:\n            # Skip if calculation fails (e.g., zero variance)\n            continue\n\n    return result\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_alpha_beta_by_day_rolling_window","title":"<code>calculate_alpha_beta_by_day_rolling_window(portfolio, target_currency, window_size, benchmark_ticker=BENCHMARK_SP500, rf_manager=None, start_date=None, end_date=None, trading_days_per_year=252, price_manager=None)</code>","text":"<p>Calculate rolling window alpha/beta for each trading day.</p> <p>For each trading day, calculates alpha/beta using the trailing window_size trading days of returns.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>window_size</code> <code>int</code> <p>Number of trailing trading days to use for each calculation.          Common values: 21 (month), 63 (quarter), 252 (year).</p> required <code>benchmark_ticker</code> <code>str</code> <p>Yahoo Finance ticker for benchmark (default: ^GSPC).</p> <code>BENCHMARK_SP500</code> <code>rf_manager</code> <code>RiskFreeRateManager | None</code> <p>Risk-free rate manager. If None, uses FRED DTB3.</p> <code>None</code> <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).</p> <code>None</code> <code>trading_days_per_year</code> <code>int</code> <p>Trading days per year for annualization (default 252).</p> <code>252</code> <code>price_manager</code> <code>PricingDataManager | None</code> <p>PricingDataManager for portfolio valuation.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[datetime, AlphaBetaResult]</code> <p>Dictionary mapping each trading day to AlphaBetaResult.</p> <code>dict[datetime, AlphaBetaResult]</code> <p>Days with insufficient observations are excluded.</p> Source code in <code>src/athena/metrics/alpha_beta.py</code> <pre><code>def calculate_alpha_beta_by_day_rolling_window(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    window_size: int,\n    benchmark_ticker: str = BENCHMARK_SP500,\n    rf_manager: RiskFreeRateManager | None = None,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    trading_days_per_year: int = 252,\n    price_manager: PricingDataManager | None = None\n) -&gt; dict[datetime, AlphaBetaResult]:\n    \"\"\"\n    Calculate rolling window alpha/beta for each trading day.\n\n    For each trading day, calculates alpha/beta using the trailing\n    window_size trading days of returns.\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        window_size: Number of trailing trading days to use for each calculation.\n                     Common values: 21 (month), 63 (quarter), 252 (year).\n        benchmark_ticker: Yahoo Finance ticker for benchmark (default: ^GSPC).\n        rf_manager: Risk-free rate manager. If None, uses FRED DTB3.\n        start_date: The start date for the calculation (inclusive).\n        end_date: The end date for the calculation (inclusive).\n        trading_days_per_year: Trading days per year for annualization (default 252).\n        price_manager: PricingDataManager for portfolio valuation.\n\n    Returns:\n        Dictionary mapping each trading day to AlphaBetaResult.\n        Days with insufficient observations are excluded.\n    \"\"\"\n    if window_size &lt; 2:\n        raise ValueError(\"window_size must be at least 2.\")\n\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; 2:\n        return {}\n\n    # Calculate strategy daily returns\n    strategy_returns = calculate_daily_returns(portfolio_values)\n\n    if len(strategy_returns) &lt; window_size:\n        return {}\n\n    # Determine date range\n    return_dates = sorted(strategy_returns.keys())\n    min_dt = return_dates[0].date()\n    max_dt = return_dates[-1].date()\n\n    # Fetch benchmark returns\n    benchmark_returns = fetch_benchmark_returns(benchmark_ticker, min_dt, max_dt)\n\n    # Create default risk-free manager if not provided\n    if rf_manager is None:\n        rf_manager = _get_default_risk_free_manager(min_dt, max_dt)\n\n    # Align returns\n    aligned_strategy, aligned_benchmark, aligned_rf, aligned_dates = align_strategy_with_benchmark(\n        strategy_returns,\n        benchmark_returns,\n        rf_manager,\n        trading_days_per_year\n    )\n\n    if len(aligned_strategy) &lt; window_size:\n        return {}\n\n    # Calculate rolling alpha/beta for each trading day\n    result: dict[datetime, AlphaBetaResult] = {}\n\n    for i in range(window_size - 1, len(aligned_dates)):\n        window_strategy = aligned_strategy[i - window_size + 1:i + 1]\n        window_benchmark = aligned_benchmark[i - window_size + 1:i + 1]\n        window_rf = aligned_rf[i - window_size + 1:i + 1]\n        dt = aligned_dates[i]\n\n        try:\n            ab_result = calculate_alpha_beta(\n                window_strategy,\n                window_benchmark,\n                window_rf,\n                trading_days_per_year\n            )\n            result[dt] = ab_result\n        except ValueError:\n            # Skip if calculation fails\n            continue\n\n    return result\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_alpha_beta_cumulative","title":"<code>calculate_alpha_beta_cumulative(portfolio, target_currency, benchmark_ticker=BENCHMARK_SP500, rf_manager=None, start_date=None, end_date=None, trading_days_per_year=252, price_manager=None)</code>","text":"<p>Calculate cumulative alpha and beta for a portfolio vs benchmark.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>benchmark_ticker</code> <code>str</code> <p>Yahoo Finance ticker for benchmark (default: ^GSPC).</p> <code>BENCHMARK_SP500</code> <code>rf_manager</code> <code>RiskFreeRateManager | None</code> <p>Risk-free rate manager. If None, uses FRED DTB3.</p> <code>None</code> <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).         If None, uses the earliest transaction date.</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).       If None, uses the latest transaction date.</p> <code>None</code> <code>trading_days_per_year</code> <code>int</code> <p>Trading days per year for annualization (default 252).</p> <code>252</code> <code>price_manager</code> <code>PricingDataManager | None</code> <p>PricingDataManager for portfolio valuation.            If None, uses YFinancePricingDataManager.</p> <code>None</code> <p>Returns:</p> Type Description <code>AlphaBetaResult</code> <p>AlphaBetaResult with alpha, beta, r_squared, and correlation.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If insufficient data or calculation error.</p> Source code in <code>src/athena/metrics/alpha_beta.py</code> <pre><code>def calculate_alpha_beta_cumulative(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    benchmark_ticker: str = BENCHMARK_SP500,\n    rf_manager: RiskFreeRateManager | None = None,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    trading_days_per_year: int = 252,\n    price_manager: PricingDataManager | None = None\n) -&gt; AlphaBetaResult:\n    \"\"\"\n    Calculate cumulative alpha and beta for a portfolio vs benchmark.\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        benchmark_ticker: Yahoo Finance ticker for benchmark (default: ^GSPC).\n        rf_manager: Risk-free rate manager. If None, uses FRED DTB3.\n        start_date: The start date for the calculation (inclusive).\n                    If None, uses the earliest transaction date.\n        end_date: The end date for the calculation (inclusive).\n                  If None, uses the latest transaction date.\n        trading_days_per_year: Trading days per year for annualization (default 252).\n        price_manager: PricingDataManager for portfolio valuation.\n                       If None, uses YFinancePricingDataManager.\n\n    Returns:\n        AlphaBetaResult with alpha, beta, r_squared, and correlation.\n\n    Raises:\n        ValueError: If insufficient data or calculation error.\n    \"\"\"\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; 2:\n        raise ValueError(\"Need at least two portfolio value observations.\")\n\n    # Calculate strategy daily returns\n    strategy_returns = calculate_daily_returns(portfolio_values)\n\n    if len(strategy_returns) &lt; 2:\n        raise ValueError(\"Need at least two return observations.\")\n\n    # Determine date range\n    return_dates = sorted(strategy_returns.keys())\n    min_date = return_dates[0].date()\n    max_date = return_dates[-1].date()\n\n    # Fetch benchmark returns\n    benchmark_returns = fetch_benchmark_returns(\n        benchmark_ticker,\n        min_date,\n        max_date\n    )\n\n    # Create default risk-free manager if not provided\n    if rf_manager is None:\n        rf_manager = _get_default_risk_free_manager(min_date, max_date)\n\n    # Align returns\n    aligned_strategy, aligned_benchmark, aligned_rf, _ = align_strategy_with_benchmark(\n        strategy_returns,\n        benchmark_returns,\n        rf_manager,\n        trading_days_per_year\n    )\n\n    if len(aligned_strategy) &lt; 2:\n        raise ValueError(\n            \"Need at least two aligned observations after filtering to trading days.\"\n        )\n\n    return calculate_alpha_beta(\n        aligned_strategy,\n        aligned_benchmark,\n        aligned_rf,\n        trading_days_per_year\n    )\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_alpha_beta_from_values","title":"<code>calculate_alpha_beta_from_values(portfolio_values, benchmark_ticker=BENCHMARK_SP500, rf_manager=None, trading_days_per_year=252)</code>","text":"<p>Calculate alpha/beta directly from portfolio values dictionary.</p> <p>Convenience function when you already have portfolio values and don't need to calculate them from a Portfolio object.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio_values</code> <code>dict[datetime, Decimal]</code> <p>Dictionary mapping dates to portfolio values.</p> required <code>benchmark_ticker</code> <code>str</code> <p>Yahoo Finance ticker for benchmark (default: ^GSPC).</p> <code>BENCHMARK_SP500</code> <code>rf_manager</code> <code>RiskFreeRateManager | None</code> <p>Risk-free rate manager. If None, uses FRED DTB3.</p> <code>None</code> <code>trading_days_per_year</code> <code>int</code> <p>Trading days per year for annualization (default 252).</p> <code>252</code> <p>Returns:</p> Type Description <code>AlphaBetaResult</code> <p>AlphaBetaResult with alpha, beta, r_squared, and correlation.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If insufficient data or calculation error.</p> Source code in <code>src/athena/metrics/alpha_beta.py</code> <pre><code>def calculate_alpha_beta_from_values(\n    portfolio_values: dict[datetime, Decimal],\n    benchmark_ticker: str = BENCHMARK_SP500,\n    rf_manager: RiskFreeRateManager | None = None,\n    trading_days_per_year: int = 252\n) -&gt; AlphaBetaResult:\n    \"\"\"\n    Calculate alpha/beta directly from portfolio values dictionary.\n\n    Convenience function when you already have portfolio values and don't\n    need to calculate them from a Portfolio object.\n\n    Args:\n        portfolio_values: Dictionary mapping dates to portfolio values.\n        benchmark_ticker: Yahoo Finance ticker for benchmark (default: ^GSPC).\n        rf_manager: Risk-free rate manager. If None, uses FRED DTB3.\n        trading_days_per_year: Trading days per year for annualization (default 252).\n\n    Returns:\n        AlphaBetaResult with alpha, beta, r_squared, and correlation.\n\n    Raises:\n        ValueError: If insufficient data or calculation error.\n    \"\"\"\n    # Calculate strategy daily returns\n    strategy_returns = calculate_daily_returns(portfolio_values)\n\n    if len(strategy_returns) &lt; 2:\n        raise ValueError(\"Need at least two return observations.\")\n\n    # Determine date range\n    return_dates = sorted(strategy_returns.keys())\n    min_date = return_dates[0].date()\n    max_date = return_dates[-1].date()\n\n    # Fetch benchmark returns\n    benchmark_returns = fetch_benchmark_returns(benchmark_ticker, min_date, max_date)\n\n    # Create default risk-free manager if not provided\n    if rf_manager is None:\n        rf_manager = _get_default_risk_free_manager(min_date, max_date)\n\n    # Align returns\n    aligned_strategy, aligned_benchmark, aligned_rf, _ = align_strategy_with_benchmark(\n        strategy_returns,\n        benchmark_returns,\n        rf_manager,\n        trading_days_per_year\n    )\n\n    if len(aligned_strategy) &lt; 2:\n        raise ValueError(\n            \"Need at least two aligned observations after filtering to trading days.\"\n        )\n\n    return calculate_alpha_beta(\n        aligned_strategy,\n        aligned_benchmark,\n        aligned_rf,\n        trading_days_per_year\n    )\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.fetch_benchmark_returns","title":"<code>fetch_benchmark_returns(benchmark_ticker, min_date, max_date, force_cache_refresh=False)</code>","text":"<p>Fetch benchmark price data and calculate daily returns.</p> <p>Parameters:</p> Name Type Description Default <code>benchmark_ticker</code> <code>str</code> <p>Yahoo Finance ticker (e.g., \"^GSPC\" for S&amp;P 500).</p> required <code>min_date</code> <code>date</code> <p>Start date for data.</p> required <code>max_date</code> <code>date</code> <p>End date for data.</p> required <code>force_cache_refresh</code> <code>bool</code> <p>Whether to force refresh cached data.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[datetime, float]</code> <p>Dictionary mapping dates to daily returns.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no benchmark data is available.</p> Source code in <code>src/athena/metrics/alpha_beta.py</code> <pre><code>def fetch_benchmark_returns(\n    benchmark_ticker: str,\n    min_date: date,\n    max_date: date,\n    force_cache_refresh: bool = False\n) -&gt; dict[datetime, float]:\n    \"\"\"\n    Fetch benchmark price data and calculate daily returns.\n\n    Args:\n        benchmark_ticker: Yahoo Finance ticker (e.g., \"^GSPC\" for S&amp;P 500).\n        min_date: Start date for data.\n        max_date: End date for data.\n        force_cache_refresh: Whether to force refresh cached data.\n\n    Returns:\n        Dictionary mapping dates to daily returns.\n\n    Raises:\n        ValueError: If no benchmark data is available.\n    \"\"\"\n    df = fetch_yfinance_data(benchmark_ticker, min_date, max_date, force_cache_refresh)\n\n    if df.empty:\n        raise ValueError(f\"No benchmark data available for {benchmark_ticker}\")\n\n    # Calculate daily returns from Close prices\n    returns: dict[datetime, float] = {}\n    sorted_df = df.sort_values('Date')\n\n    prev_close = None\n    for _, row in sorted_df.iterrows():\n        current_close = float(row['Close'])\n        current_date = row['Date']\n\n        if prev_close is not None and prev_close != 0:\n            daily_return = (current_close - prev_close) / prev_close\n            # Convert date to datetime for consistency with portfolio returns\n            dt = datetime.combine(current_date, datetime.min.time())\n            returns[dt] = daily_return\n\n        prev_close = current_close\n\n    return returns\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_drawdown_series","title":"<code>calculate_drawdown_series(portfolio_values)</code>","text":"<p>Calculate the drawdown at each point in time from a time series of portfolio values.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio_values</code> <code>dict[datetime, Decimal]</code> <p>Dictionary mapping dates to portfolio values.</p> required <p>Returns:</p> Type Description <code>dict[datetime, float]</code> <p>Dictionary mapping dates to drawdown values (negative floats).</p> <code>dict[datetime, float]</code> <p>A drawdown of -0.10 means the portfolio is 10% below its peak.</p> Source code in <code>src/athena/metrics/max_drawdown.py</code> <pre><code>def calculate_drawdown_series(\n    portfolio_values: dict[datetime, Decimal]\n) -&gt; dict[datetime, float]:\n    \"\"\"\n    Calculate the drawdown at each point in time from a time series of portfolio values.\n\n    Args:\n        portfolio_values: Dictionary mapping dates to portfolio values.\n\n    Returns:\n        Dictionary mapping dates to drawdown values (negative floats).\n        A drawdown of -0.10 means the portfolio is 10% below its peak.\n    \"\"\"\n    if len(portfolio_values) &lt; 1:\n        return {}\n\n    sorted_dates = sorted(portfolio_values.keys())\n    values = [float(portfolio_values[d]) for d in sorted_dates]\n\n    drawdowns: dict[datetime, float] = {}\n    peak_value = values[0]\n\n    for date, value in zip(sorted_dates, values):\n        if value &gt; peak_value:\n            peak_value = value\n\n        if peak_value &gt; 0:\n            drawdowns[date] = (value - peak_value) / peak_value\n        else:\n            drawdowns[date] = 0.0\n\n    return drawdowns\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_max_drawdown","title":"<code>calculate_max_drawdown(portfolio_values)</code>","text":"<p>Calculate the maximum drawdown from a time series of portfolio values.</p> <p>Maximum drawdown measures the largest peak-to-trough decline in portfolio value, expressed as a percentage of the peak value.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio_values</code> <code>dict[datetime, Decimal]</code> <p>Dictionary mapping dates to portfolio values.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Tuple of (max_drawdown, peak_date, trough_date).</p> <code>datetime | None</code> <p>max_drawdown is a negative float (e.g., -0.20 = 20% drawdown).</p> <code>datetime | None</code> <p>peak_date and trough_date are None if insufficient data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two observations.</p> Source code in <code>src/athena/metrics/max_drawdown.py</code> <pre><code>def calculate_max_drawdown(\n    portfolio_values: dict[datetime, Decimal]\n) -&gt; Tuple[float, datetime | None, datetime | None]:\n    \"\"\"\n    Calculate the maximum drawdown from a time series of portfolio values.\n\n    Maximum drawdown measures the largest peak-to-trough decline in portfolio\n    value, expressed as a percentage of the peak value.\n\n    Args:\n        portfolio_values: Dictionary mapping dates to portfolio values.\n\n    Returns:\n        Tuple of (max_drawdown, peak_date, trough_date).\n        max_drawdown is a negative float (e.g., -0.20 = 20% drawdown).\n        peak_date and trough_date are None if insufficient data.\n\n    Raises:\n        ValueError: If fewer than two observations.\n    \"\"\"\n    if len(portfolio_values) &lt; 2:\n        raise ValueError(\"Need at least two portfolio value observations.\")\n\n    sorted_dates = sorted(portfolio_values.keys())\n    values = [float(portfolio_values[d]) for d in sorted_dates]\n\n    max_drawdown = 0.0\n    peak_value = values[0]\n    peak_date: datetime | None = sorted_dates[0]\n    trough_date: datetime | None = None\n    current_peak_date = sorted_dates[0]\n\n    for i, (date, value) in enumerate(zip(sorted_dates, values)):\n        if value &gt; peak_value:\n            peak_value = value\n            current_peak_date = date\n\n        if peak_value &gt; 0:\n            drawdown = (value - peak_value) / peak_value\n            if drawdown &lt; max_drawdown:\n                max_drawdown = drawdown\n                peak_date = current_peak_date\n                trough_date = date\n\n    return max_drawdown, peak_date, trough_date\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_max_drawdown_by_day_cumulative","title":"<code>calculate_max_drawdown_by_day_cumulative(portfolio, target_currency, start_date=None, end_date=None, min_observations=2)</code>","text":"<p>Calculate cumulative maximum drawdown for each day in a date range.</p> <p>For each day, calculates the maximum drawdown using all portfolio values from start_date up to that day (cumulative/expanding window).</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).         If None, uses the earliest transaction date.</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).       If None, uses the latest transaction date.</p> <code>None</code> <code>min_observations</code> <code>int</code> <p>Minimum number of observations required               before calculating max drawdown. Defaults to 2.</p> <code>2</code> <p>Returns:</p> Type Description <code>dict[datetime, float]</code> <p>Dictionary mapping each date to the cumulative max drawdown up to that date.</p> <code>dict[datetime, float]</code> <p>Days with insufficient observations are excluded.</p> Source code in <code>src/athena/metrics/max_drawdown.py</code> <pre><code>def calculate_max_drawdown_by_day_cumulative(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    min_observations: int = 2\n) -&gt; dict[datetime, float]:\n    \"\"\"\n    Calculate cumulative maximum drawdown for each day in a date range.\n\n    For each day, calculates the maximum drawdown using all portfolio values\n    from start_date up to that day (cumulative/expanding window).\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        start_date: The start date for the calculation (inclusive).\n                    If None, uses the earliest transaction date.\n        end_date: The end date for the calculation (inclusive).\n                  If None, uses the latest transaction date.\n        min_observations: Minimum number of observations required\n                          before calculating max drawdown. Defaults to 2.\n\n    Returns:\n        Dictionary mapping each date to the cumulative max drawdown up to that date.\n        Days with insufficient observations are excluded.\n    \"\"\"\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; min_observations:\n        return {}\n\n    sorted_dates = sorted(portfolio_values.keys())\n    values = [float(portfolio_values[d]) for d in sorted_dates]\n\n    result: dict[datetime, float] = {}\n    max_drawdown = 0.0\n    peak_value = values[0]\n\n    for i, (date, value) in enumerate(zip(sorted_dates, values)):\n        if value &gt; peak_value:\n            peak_value = value\n\n        if peak_value &gt; 0:\n            drawdown = (value - peak_value) / peak_value\n            if drawdown &lt; max_drawdown:\n                max_drawdown = drawdown\n\n        if i + 1 &gt;= min_observations:\n            result[date] = max_drawdown\n\n    return result\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_max_drawdown_by_day_rolling_window","title":"<code>calculate_max_drawdown_by_day_rolling_window(portfolio, target_currency, window_size, start_date=None, end_date=None)</code>","text":"<p>Calculate rolling window maximum drawdown for each day in a date range.</p> <p>For each day, calculates the maximum drawdown using the trailing window_size days of portfolio values.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>window_size</code> <code>int</code> <p>Number of trailing days to use for each calculation.          Common values: 30, 60, 90, 252 (trading year).</p> required <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).         If None, uses the earliest transaction date.</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).       If None, uses the latest transaction date.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[datetime, float]</code> <p>Dictionary mapping each date to the rolling max drawdown.</p> <code>dict[datetime, float]</code> <p>Days with insufficient observations (fewer than window_size) are excluded.</p> Source code in <code>src/athena/metrics/max_drawdown.py</code> <pre><code>def calculate_max_drawdown_by_day_rolling_window(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    window_size: int,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None\n) -&gt; dict[datetime, float]:\n    \"\"\"\n    Calculate rolling window maximum drawdown for each day in a date range.\n\n    For each day, calculates the maximum drawdown using the trailing\n    window_size days of portfolio values.\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        window_size: Number of trailing days to use for each calculation.\n                     Common values: 30, 60, 90, 252 (trading year).\n        start_date: The start date for the calculation (inclusive).\n                    If None, uses the earliest transaction date.\n        end_date: The end date for the calculation (inclusive).\n                  If None, uses the latest transaction date.\n\n    Returns:\n        Dictionary mapping each date to the rolling max drawdown.\n        Days with insufficient observations (fewer than window_size) are excluded.\n    \"\"\"\n    if window_size &lt; 2:\n        raise ValueError(\"window_size must be at least 2.\")\n\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; window_size:\n        return {}\n\n    sorted_dates = sorted(portfolio_values.keys())\n    values = [float(portfolio_values[d]) for d in sorted_dates]\n\n    result: dict[datetime, float] = {}\n\n    for i in range(window_size - 1, len(sorted_dates)):\n        window_values = values[i - window_size + 1:i + 1]\n        date = sorted_dates[i]\n\n        # Calculate max drawdown for this window\n        max_drawdown = 0.0\n        peak_value = window_values[0]\n\n        for value in window_values:\n            if value &gt; peak_value:\n                peak_value = value\n\n            if peak_value &gt; 0:\n                drawdown = (value - peak_value) / peak_value\n                if drawdown &lt; max_drawdown:\n                    max_drawdown = drawdown\n\n        result[date] = max_drawdown\n\n    return result\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_max_drawdown_cumulative","title":"<code>calculate_max_drawdown_cumulative(portfolio, target_currency, start_date=None, end_date=None)</code>","text":"<p>Calculate the maximum drawdown for a portfolio over a date range.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).         If None, uses the earliest transaction date.</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).       If None, uses the latest transaction date.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Tuple of (max_drawdown, peak_date, trough_date).</p> <code>datetime | None</code> <p>max_drawdown is a negative float (e.g., -0.20 = 20% drawdown).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two observations.</p> Source code in <code>src/athena/metrics/max_drawdown.py</code> <pre><code>def calculate_max_drawdown_cumulative(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None\n) -&gt; Tuple[float, datetime | None, datetime | None]:\n    \"\"\"\n    Calculate the maximum drawdown for a portfolio over a date range.\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        start_date: The start date for the calculation (inclusive).\n                    If None, uses the earliest transaction date.\n        end_date: The end date for the calculation (inclusive).\n                  If None, uses the latest transaction date.\n\n    Returns:\n        Tuple of (max_drawdown, peak_date, trough_date).\n        max_drawdown is a negative float (e.g., -0.20 = 20% drawdown).\n\n    Raises:\n        ValueError: If fewer than two observations.\n    \"\"\"\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; 2:\n        raise ValueError(\"Need at least two portfolio value observations.\")\n\n    return calculate_max_drawdown(portfolio_values)\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_max_drawdown_from_values","title":"<code>calculate_max_drawdown_from_values(portfolio_values)</code>","text":"<p>Calculate maximum drawdown directly from a dictionary of portfolio values.</p> <p>This is a convenience function when you already have portfolio values and don't need to calculate them from a Portfolio object.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio_values</code> <code>dict[datetime, Decimal]</code> <p>Dictionary mapping dates to portfolio values.</p> required <p>Returns:</p> Type Description <code>float</code> <p>Tuple of (max_drawdown, peak_date, trough_date).</p> <code>datetime | None</code> <p>max_drawdown is a negative float (e.g., -0.20 = 20% drawdown).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two observations.</p> Source code in <code>src/athena/metrics/max_drawdown.py</code> <pre><code>def calculate_max_drawdown_from_values(\n    portfolio_values: dict[datetime, Decimal]\n) -&gt; Tuple[float, datetime | None, datetime | None]:\n    \"\"\"\n    Calculate maximum drawdown directly from a dictionary of portfolio values.\n\n    This is a convenience function when you already have portfolio values\n    and don't need to calculate them from a Portfolio object.\n\n    Args:\n        portfolio_values: Dictionary mapping dates to portfolio values.\n\n    Returns:\n        Tuple of (max_drawdown, peak_date, trough_date).\n        max_drawdown is a negative float (e.g., -0.20 = 20% drawdown).\n\n    Raises:\n        ValueError: If fewer than two observations.\n    \"\"\"\n    return calculate_max_drawdown(portfolio_values)\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_daily_returns","title":"<code>calculate_daily_returns(portfolio_values)</code>","text":"<p>Calculate daily returns from a time series of portfolio values.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio_values</code> <code>dict[datetime, Decimal]</code> <p>Dictionary mapping dates to portfolio values.</p> required <p>Returns:</p> Type Description <code>dict[datetime, float]</code> <p>Dictionary mapping dates to daily returns (as floats).</p> <code>dict[datetime, float]</code> <p>The first date will not have a return (needs previous day).</p> Source code in <code>src/athena/metrics/sharpe.py</code> <pre><code>def calculate_daily_returns(\n    portfolio_values: dict[datetime, Decimal]\n) -&gt; dict[datetime, float]:\n    \"\"\"\n    Calculate daily returns from a time series of portfolio values.\n\n    Args:\n        portfolio_values: Dictionary mapping dates to portfolio values.\n\n    Returns:\n        Dictionary mapping dates to daily returns (as floats).\n        The first date will not have a return (needs previous day).\n    \"\"\"\n    if len(portfolio_values) &lt; 2:\n        return {}\n\n    sorted_dates = sorted(portfolio_values.keys())\n    returns: dict[datetime, float] = {}\n\n    for i in range(1, len(sorted_dates)):\n        prev_date = sorted_dates[i - 1]\n        curr_date = sorted_dates[i]\n\n        prev_value = float(portfolio_values[prev_date])\n        curr_value = float(portfolio_values[curr_date])\n\n        if prev_value != 0:\n            daily_return = (curr_value - prev_value) / prev_value\n            returns[curr_date] = daily_return\n\n    return returns\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_sharpe_ratio","title":"<code>calculate_sharpe_ratio(returns, annual_risk_free_rate, periods_in_year=365)</code>","text":"<p>Calculate daily and annualized Sharpe ratios from a list of returns.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>list[float]</code> <p>List of daily returns as decimals (e.g., 0.002 = 0.2%).</p> required <code>annual_risk_free_rate</code> <code>float</code> <p>Annual nominal risk-free rate (e.g., 0.03 for 3%).</p> required <code>periods_in_year</code> <code>int</code> <p>Trading periods in a year (365 for daily).</p> <code>365</code> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of (daily_sharpe, annual_sharpe).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two observations or zero standard deviation.</p> Source code in <code>src/athena/metrics/sharpe.py</code> <pre><code>def calculate_sharpe_ratio(\n    returns: list[float],\n    annual_risk_free_rate: float,\n    periods_in_year: int = 365\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Calculate daily and annualized Sharpe ratios from a list of returns.\n\n    Args:\n        returns: List of daily returns as decimals (e.g., 0.002 = 0.2%).\n        annual_risk_free_rate: Annual nominal risk-free rate (e.g., 0.03 for 3%).\n        periods_in_year: Trading periods in a year (365 for daily).\n\n    Returns:\n        Tuple of (daily_sharpe, annual_sharpe).\n\n    Raises:\n        ValueError: If fewer than two observations or zero standard deviation.\n    \"\"\"\n    if len(returns) &lt; 2:\n        raise ValueError(\"Need at least two return observations.\")\n\n    daily_rf = annual_risk_free_rate / periods_in_year\n\n    excess_returns = np.array(returns, dtype=float) - daily_rf\n    mean_excess = excess_returns.mean()\n    std_excess = excess_returns.std(ddof=1)\n\n    if np.isclose(std_excess, 0.0):\n        raise ValueError(\"Sample standard deviation is zero; Sharpe is undefined.\")\n\n    daily_sharpe = float(mean_excess / std_excess)\n    annual_sharpe = daily_sharpe * np.sqrt(periods_in_year)\n\n    return daily_sharpe, annual_sharpe\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_sharpe_ratio_by_day_cumulative","title":"<code>calculate_sharpe_ratio_by_day_cumulative(portfolio, target_currency, annual_risk_free_rate, start_date=None, end_date=None, periods_in_year=365, min_observations=2)</code>","text":"<p>Calculate cumulative Sharpe ratios for each day in a date range.</p> <p>For each day, calculates the Sharpe ratio using all returns from start_date up to that day (cumulative/expanding window).</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>annual_risk_free_rate</code> <code>float</code> <p>Annual nominal risk-free rate (e.g., 0.03 for 3%).</p> required <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).         If None, uses the earliest transaction date.</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).       If None, uses the latest transaction date.</p> <code>None</code> <code>periods_in_year</code> <code>int</code> <p>Trading periods in a year (365 for daily, 252 for              US equities trading days).</p> <code>365</code> <code>min_observations</code> <code>int</code> <p>Minimum number of return observations required               before calculating Sharpe. Defaults to 2.</p> <code>2</code> <p>Returns:</p> Type Description <code>dict[datetime, Tuple[float, float]]</code> <p>Dictionary mapping each date to a tuple of (daily_sharpe, annual_sharpe).</p> <code>dict[datetime, Tuple[float, float]]</code> <p>Days with insufficient observations are excluded.</p> Source code in <code>src/athena/metrics/sharpe.py</code> <pre><code>def calculate_sharpe_ratio_by_day_cumulative(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    annual_risk_free_rate: float,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    periods_in_year: int = 365,\n    min_observations: int = 2\n) -&gt; dict[datetime, Tuple[float, float]]:\n    \"\"\"\n    Calculate cumulative Sharpe ratios for each day in a date range.\n\n    For each day, calculates the Sharpe ratio using all returns from\n    start_date up to that day (cumulative/expanding window).\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        annual_risk_free_rate: Annual nominal risk-free rate (e.g., 0.03 for 3%).\n        start_date: The start date for the calculation (inclusive).\n                    If None, uses the earliest transaction date.\n        end_date: The end date for the calculation (inclusive).\n                  If None, uses the latest transaction date.\n        periods_in_year: Trading periods in a year (365 for daily, 252 for\n                         US equities trading days).\n        min_observations: Minimum number of return observations required\n                          before calculating Sharpe. Defaults to 2.\n\n    Returns:\n        Dictionary mapping each date to a tuple of (daily_sharpe, annual_sharpe).\n        Days with insufficient observations are excluded.\n    \"\"\"\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; 2:\n        return {}\n\n    # Calculate daily returns\n    daily_returns = calculate_daily_returns(portfolio_values)\n\n    if len(daily_returns) &lt; min_observations:\n        return {}\n\n    # Calculate cumulative Sharpe for each day\n    sorted_dates = sorted(daily_returns.keys())\n    daily_rf = annual_risk_free_rate / periods_in_year\n\n    result: dict[datetime, Tuple[float, float]] = {}\n    cumulative_returns: list[float] = []\n\n    for date in sorted_dates:\n        cumulative_returns.append(daily_returns[date])\n\n        if len(cumulative_returns) &lt; min_observations:\n            continue\n\n        excess_returns = np.array(cumulative_returns, dtype=float) - daily_rf\n        mean_excess = excess_returns.mean()\n        std_excess = excess_returns.std(ddof=1)\n\n        if np.isclose(std_excess, 0.0):\n            # Skip days where std is zero\n            continue\n\n        daily_sharpe = float(mean_excess / std_excess)\n        annual_sharpe = daily_sharpe * np.sqrt(periods_in_year)\n\n        result[date] = (daily_sharpe, annual_sharpe)\n\n    return result\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_sharpe_ratio_by_day_rolling_window","title":"<code>calculate_sharpe_ratio_by_day_rolling_window(portfolio, target_currency, annual_risk_free_rate, window_size, start_date=None, end_date=None, periods_in_year=365)</code>","text":"<p>Calculate rolling window Sharpe ratios for each day in a date range.</p> <p>For each day, calculates the Sharpe ratio using the trailing window_size days of returns.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>annual_risk_free_rate</code> <code>float</code> <p>Annual nominal risk-free rate (e.g., 0.03 for 3%).</p> required <code>window_size</code> <code>int</code> <p>Number of trailing days to use for each calculation.          Common values: 30, 60, 90, 252 (trading year).</p> required <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).         If None, uses the earliest transaction date.</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).       If None, uses the latest transaction date.</p> <code>None</code> <code>periods_in_year</code> <code>int</code> <p>Trading periods in a year (365 for daily, 252 for              US equities trading days).</p> <code>365</code> <p>Returns:</p> Type Description <code>dict[datetime, Tuple[float, float]]</code> <p>Dictionary mapping each date to a tuple of (daily_sharpe, annual_sharpe).</p> <code>dict[datetime, Tuple[float, float]]</code> <p>Days with insufficient observations (fewer than window_size) are excluded.</p> Source code in <code>src/athena/metrics/sharpe.py</code> <pre><code>def calculate_sharpe_ratio_by_day_rolling_window(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    annual_risk_free_rate: float,\n    window_size: int,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    periods_in_year: int = 365\n) -&gt; dict[datetime, Tuple[float, float]]:\n    \"\"\"\n    Calculate rolling window Sharpe ratios for each day in a date range.\n\n    For each day, calculates the Sharpe ratio using the trailing\n    window_size days of returns.\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        annual_risk_free_rate: Annual nominal risk-free rate (e.g., 0.03 for 3%).\n        window_size: Number of trailing days to use for each calculation.\n                     Common values: 30, 60, 90, 252 (trading year).\n        start_date: The start date for the calculation (inclusive).\n                    If None, uses the earliest transaction date.\n        end_date: The end date for the calculation (inclusive).\n                  If None, uses the latest transaction date.\n        periods_in_year: Trading periods in a year (365 for daily, 252 for\n                         US equities trading days).\n\n    Returns:\n        Dictionary mapping each date to a tuple of (daily_sharpe, annual_sharpe).\n        Days with insufficient observations (fewer than window_size) are excluded.\n    \"\"\"\n    if window_size &lt; 2:\n        raise ValueError(\"window_size must be at least 2.\")\n\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; 2:\n        return {}\n\n    # Calculate daily returns\n    daily_returns = calculate_daily_returns(portfolio_values)\n\n    if len(daily_returns) &lt; window_size:\n        return {}\n\n    # Calculate rolling Sharpe for each day\n    sorted_dates = sorted(daily_returns.keys())\n    returns_list = [daily_returns[d] for d in sorted_dates]\n    daily_rf = annual_risk_free_rate / periods_in_year\n\n    result: dict[datetime, Tuple[float, float]] = {}\n\n    for i in range(window_size - 1, len(sorted_dates)):\n        window_returns = returns_list[i - window_size + 1:i + 1]\n        date = sorted_dates[i]\n\n        excess_returns = np.array(window_returns, dtype=float) - daily_rf\n        mean_excess = excess_returns.mean()\n        std_excess = excess_returns.std(ddof=1)\n\n        if np.isclose(std_excess, 0.0):\n            # Skip days where std is zero\n            continue\n\n        daily_sharpe = float(mean_excess / std_excess)\n        annual_sharpe = daily_sharpe * np.sqrt(periods_in_year)\n\n        result[date] = (daily_sharpe, annual_sharpe)\n\n    return result\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_sharpe_ratio_cumulative","title":"<code>calculate_sharpe_ratio_cumulative(portfolio, target_currency, annual_risk_free_rate, start_date=None, end_date=None, periods_in_year=365)</code>","text":"<p>Calculate the cumulative Sharpe ratio for a portfolio over a date range.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>annual_risk_free_rate</code> <code>float</code> <p>Annual nominal risk-free rate (e.g., 0.03 for 3%).</p> required <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).         If None, uses the earliest transaction date.</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).       If None, uses the latest transaction date.</p> <code>None</code> <code>periods_in_year</code> <code>int</code> <p>Trading periods in a year (365 for daily, 252 for              US equities trading days).</p> <code>365</code> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of (daily_sharpe, annual_sharpe).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two observations or zero standard deviation.</p> Source code in <code>src/athena/metrics/sharpe.py</code> <pre><code>def calculate_sharpe_ratio_cumulative(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    annual_risk_free_rate: float,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    periods_in_year: int = 365\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Calculate the cumulative Sharpe ratio for a portfolio over a date range.\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        annual_risk_free_rate: Annual nominal risk-free rate (e.g., 0.03 for 3%).\n        start_date: The start date for the calculation (inclusive).\n                    If None, uses the earliest transaction date.\n        end_date: The end date for the calculation (inclusive).\n                  If None, uses the latest transaction date.\n        periods_in_year: Trading periods in a year (365 for daily, 252 for\n                         US equities trading days).\n\n    Returns:\n        Tuple of (daily_sharpe, annual_sharpe).\n\n    Raises:\n        ValueError: If fewer than two observations or zero standard deviation.\n    \"\"\"\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; 2:\n        raise ValueError(\"Need at least two portfolio value observations.\")\n\n    # Calculate daily returns\n    daily_returns = calculate_daily_returns(portfolio_values)\n\n    if len(daily_returns) &lt; 2:\n        raise ValueError(\"Need at least two return observations.\")\n\n    # Calculate Sharpe ratio\n    returns_list = [daily_returns[d] for d in sorted(daily_returns.keys())]\n    return calculate_sharpe_ratio(returns_list, annual_risk_free_rate, periods_in_year)\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_sharpe_ratio_from_values","title":"<code>calculate_sharpe_ratio_from_values(portfolio_values, annual_risk_free_rate, periods_in_year=365)</code>","text":"<p>Calculate Sharpe ratios directly from a dictionary of portfolio values.</p> <p>This is a convenience function when you already have portfolio values and don't need to calculate them from a Portfolio object.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio_values</code> <code>dict[datetime, Decimal]</code> <p>Dictionary mapping dates to portfolio values.</p> required <code>annual_risk_free_rate</code> <code>float</code> <p>Annual nominal risk-free rate (e.g., 0.03 for 3%).</p> required <code>periods_in_year</code> <code>int</code> <p>Trading periods in a year (365 for daily).</p> <code>365</code> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of (daily_sharpe, annual_sharpe).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two observations or zero standard deviation.</p> Source code in <code>src/athena/metrics/sharpe.py</code> <pre><code>def calculate_sharpe_ratio_from_values(\n    portfolio_values: dict[datetime, Decimal],\n    annual_risk_free_rate: float,\n    periods_in_year: int = 365\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Calculate Sharpe ratios directly from a dictionary of portfolio values.\n\n    This is a convenience function when you already have portfolio values\n    and don't need to calculate them from a Portfolio object.\n\n    Args:\n        portfolio_values: Dictionary mapping dates to portfolio values.\n        annual_risk_free_rate: Annual nominal risk-free rate (e.g., 0.03 for 3%).\n        periods_in_year: Trading periods in a year (365 for daily).\n\n    Returns:\n        Tuple of (daily_sharpe, annual_sharpe).\n\n    Raises:\n        ValueError: If fewer than two observations or zero standard deviation.\n    \"\"\"\n    daily_returns = calculate_daily_returns(portfolio_values)\n\n    if len(daily_returns) &lt; 2:\n        raise ValueError(\"Need at least two return observations.\")\n\n    returns_list = [daily_returns[d] for d in sorted(daily_returns.keys())]\n\n    return calculate_sharpe_ratio(returns_list, annual_risk_free_rate, periods_in_year)\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.align_returns_with_risk_free_rates","title":"<code>align_returns_with_risk_free_rates(portfolio_returns, rf_manager, trading_days_per_year=252)</code>","text":"<p>Align portfolio returns with risk-free rates on trading days only.</p> <p>Includes dates where portfolio returns exist and either: - Actual risk-free rate data is available for that date, OR - It's a recent weekday where FRED data may not be published yet   (uses most recent available rate as fallback)</p> <p>Weekends are always excluded.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio_returns</code> <code>dict[datetime, float]</code> <p>Dictionary mapping dates to portfolio returns.</p> required <code>rf_manager</code> <code>RiskFreeRateManager</code> <p>Risk-free rate manager to get daily rates from.</p> required <code>trading_days_per_year</code> <code>int</code> <p>Number of trading days per year for daily rate calc.</p> <code>252</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>Tuple of (aligned_portfolio_returns, aligned_rf_rates, aligned_dates).</p> <code>list[float]</code> <p>All three lists have the same length and correspond to each other.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no overlapping dates are found.</p> Source code in <code>src/athena/metrics/sharpe_advanced.py</code> <pre><code>def align_returns_with_risk_free_rates(\n    portfolio_returns: dict[datetime, float],\n    rf_manager: RiskFreeRateManager,\n    trading_days_per_year: int = 252\n) -&gt; Tuple[list[float], list[float], list[datetime]]:\n    \"\"\"\n    Align portfolio returns with risk-free rates on trading days only.\n\n    Includes dates where portfolio returns exist and either:\n    - Actual risk-free rate data is available for that date, OR\n    - It's a recent weekday where FRED data may not be published yet\n      (uses most recent available rate as fallback)\n\n    Weekends are always excluded.\n\n    Args:\n        portfolio_returns: Dictionary mapping dates to portfolio returns.\n        rf_manager: Risk-free rate manager to get daily rates from.\n        trading_days_per_year: Number of trading days per year for daily rate calc.\n\n    Returns:\n        Tuple of (aligned_portfolio_returns, aligned_rf_rates, aligned_dates).\n        All three lists have the same length and correspond to each other.\n\n    Raises:\n        ValueError: If no overlapping dates are found.\n    \"\"\"\n    aligned_returns: list[float] = []\n    aligned_rf_rates: list[float] = []\n    aligned_dates: list[datetime] = []\n\n    sorted_dates = sorted(portfolio_returns.keys())\n\n    # Get the set of actual trading days from the risk-free rate manager\n    if hasattr(rf_manager, 'get_rates_for_range') and sorted_dates:\n        min_date = sorted_dates[0].date()\n        max_date = sorted_dates[-1].date()\n        available_rates = rf_manager.get_rates_for_range(min_date, max_date)\n        trading_days = set(available_rates.keys())\n        # Track the most recent available rate for fallback on recent days\n        last_known_rate: float | None = None\n        if available_rates:\n            most_recent_date = max(available_rates.keys())\n            last_known_rate = float(available_rates[most_recent_date])\n    else:\n        # Fallback for managers that don't support get_rates_for_range\n        trading_days = None\n        last_known_rate = None\n\n    for dt in sorted_dates:\n        dt_date = dt.date()\n\n        # Always skip weekends (Saturday=5, Sunday=6)\n        if dt_date.weekday() &gt;= 5:\n            continue\n\n        # Check if we have actual FRED data for this date\n        has_fred_data = trading_days is None or dt_date in trading_days\n\n        if has_fred_data:\n            try:\n                annual_rate = rf_manager.get_rate(dt_date)\n                daily_rf = float(annual_rate) / trading_days_per_year\n                # Update last known rate for potential future fallback\n                last_known_rate = float(annual_rate)\n\n                aligned_returns.append(portfolio_returns[dt])\n                aligned_rf_rates.append(daily_rf)\n                aligned_dates.append(dt)\n            except ValueError:\n                # No risk-free rate available for this date, skip it\n                continue\n        elif last_known_rate is not None:\n            # Recent weekday without FRED data - use last known rate as fallback\n            # This handles cases where FRED data lags by a day or two\n            daily_rf = last_known_rate / trading_days_per_year\n\n            aligned_returns.append(portfolio_returns[dt])\n            aligned_rf_rates.append(daily_rf)\n            aligned_dates.append(dt)\n        # else: skip - no fallback rate available\n\n    if len(aligned_returns) == 0:\n        raise ValueError(\n            \"No overlapping dates between portfolio returns and risk-free rate data.\"\n        )\n\n    return aligned_returns, aligned_rf_rates, aligned_dates\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_sharpe_ratio_advanced","title":"<code>calculate_sharpe_ratio_advanced(returns, daily_risk_free_rates, trading_days_per_year=252)</code>","text":"<p>Calculate Sharpe ratio using variable daily risk-free rates.</p> <p>Uses the standard (non-geometric) approach: excess_return = portfolio_return - risk_free_rate</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>list[float]</code> <p>List of daily portfolio returns (aligned with rf rates).</p> required <code>daily_risk_free_rates</code> <code>list[float]</code> <p>List of daily risk-free rates (same length as returns).</p> required <code>trading_days_per_year</code> <code>int</code> <p>Trading days per year for annualization (default 252).</p> <code>252</code> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of (daily_sharpe, annual_sharpe).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If inputs have different lengths, fewer than 2 observations,         or zero standard deviation.</p> Source code in <code>src/athena/metrics/sharpe_advanced.py</code> <pre><code>def calculate_sharpe_ratio_advanced(\n    returns: list[float],\n    daily_risk_free_rates: list[float],\n    trading_days_per_year: int = 252\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Calculate Sharpe ratio using variable daily risk-free rates.\n\n    Uses the standard (non-geometric) approach:\n    excess_return = portfolio_return - risk_free_rate\n\n    Args:\n        returns: List of daily portfolio returns (aligned with rf rates).\n        daily_risk_free_rates: List of daily risk-free rates (same length as returns).\n        trading_days_per_year: Trading days per year for annualization (default 252).\n\n    Returns:\n        Tuple of (daily_sharpe, annual_sharpe).\n\n    Raises:\n        ValueError: If inputs have different lengths, fewer than 2 observations,\n                    or zero standard deviation.\n    \"\"\"\n    if len(returns) != len(daily_risk_free_rates):\n        raise ValueError(\n            f\"Returns and risk-free rates must have same length. \"\n            f\"Got {len(returns)} returns and {len(daily_risk_free_rates)} rates.\"\n        )\n\n    if len(returns) &lt; 2:\n        raise ValueError(\"Need at least two return observations.\")\n\n    # Calculate excess returns (standard approach: simple subtraction)\n    portfolio_returns = np.array(returns, dtype=float)\n    rf_rates = np.array(daily_risk_free_rates, dtype=float)\n    excess_returns = portfolio_returns - rf_rates\n\n    mean_excess = excess_returns.mean()\n    std_excess = excess_returns.std(ddof=1)\n\n    if np.isclose(std_excess, 0.0):\n        raise ValueError(\"Sample standard deviation is zero; Sharpe is undefined.\")\n\n    daily_sharpe = float(mean_excess / std_excess)\n    annual_sharpe = daily_sharpe * np.sqrt(trading_days_per_year)\n\n    return daily_sharpe, annual_sharpe\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_sharpe_ratio_by_day_cumulative_advanced","title":"<code>calculate_sharpe_ratio_by_day_cumulative_advanced(portfolio, target_currency, rf_manager=None, start_date=None, end_date=None, trading_days_per_year=252, min_observations=2)</code>","text":"<p>Calculate cumulative Sharpe ratios for each trading day in a date range.</p> <p>For each trading day, calculates the Sharpe ratio using all returns from start_date up to that day (cumulative/expanding window).</p> <p>Only includes dates where risk-free rate data is available.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>rf_manager</code> <code>RiskFreeRateManager | None</code> <p>Risk-free rate manager. If None, uses FRED DTB3.</p> <code>None</code> <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).         If None, uses the earliest transaction date.</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).       If None, uses the latest transaction date.</p> <code>None</code> <code>trading_days_per_year</code> <code>int</code> <p>Trading days per year for annualization (default 252).</p> <code>252</code> <code>min_observations</code> <code>int</code> <p>Minimum number of observations required before               calculating Sharpe. Defaults to 2.</p> <code>2</code> <p>Returns:</p> Type Description <code>dict[datetime, Tuple[float, float]]</code> <p>Dictionary mapping each trading day to (daily_sharpe, annual_sharpe).</p> <code>dict[datetime, Tuple[float, float]]</code> <p>Days with insufficient observations are excluded.</p> Source code in <code>src/athena/metrics/sharpe_advanced.py</code> <pre><code>def calculate_sharpe_ratio_by_day_cumulative_advanced(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    rf_manager: RiskFreeRateManager | None = None,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    trading_days_per_year: int = 252,\n    min_observations: int = 2\n) -&gt; dict[datetime, Tuple[float, float]]:\n    \"\"\"\n    Calculate cumulative Sharpe ratios for each trading day in a date range.\n\n    For each trading day, calculates the Sharpe ratio using all returns from\n    start_date up to that day (cumulative/expanding window).\n\n    Only includes dates where risk-free rate data is available.\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        rf_manager: Risk-free rate manager. If None, uses FRED DTB3.\n        start_date: The start date for the calculation (inclusive).\n                    If None, uses the earliest transaction date.\n        end_date: The end date for the calculation (inclusive).\n                  If None, uses the latest transaction date.\n        trading_days_per_year: Trading days per year for annualization (default 252).\n        min_observations: Minimum number of observations required before\n                          calculating Sharpe. Defaults to 2.\n\n    Returns:\n        Dictionary mapping each trading day to (daily_sharpe, annual_sharpe).\n        Days with insufficient observations are excluded.\n    \"\"\"\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; 2:\n        return {}\n\n    # Calculate daily returns\n    daily_returns = calculate_daily_returns(portfolio_values)\n\n    if len(daily_returns) &lt; min_observations:\n        return {}\n\n    # Determine date range for risk-free rate data\n    return_dates = sorted(daily_returns.keys())\n    min_dt = return_dates[0].date()\n    max_dt = return_dates[-1].date()\n\n    # Create default manager if not provided\n    if rf_manager is None:\n        rf_manager = _get_default_risk_free_manager(min_dt, max_dt)\n\n    # Align returns with risk-free rates (trading days only)\n    aligned_returns, aligned_rf_rates, aligned_dates = align_returns_with_risk_free_rates(\n        daily_returns,\n        rf_manager,\n        trading_days_per_year\n    )\n\n    if len(aligned_returns) &lt; min_observations:\n        return {}\n\n    # Calculate cumulative Sharpe for each trading day\n    result: dict[datetime, Tuple[float, float]] = {}\n    cumulative_returns: list[float] = []\n    cumulative_rf_rates: list[float] = []\n\n    for i, dt in enumerate(aligned_dates):\n        cumulative_returns.append(aligned_returns[i])\n        cumulative_rf_rates.append(aligned_rf_rates[i])\n\n        if len(cumulative_returns) &lt; min_observations:\n            continue\n\n        excess_returns = np.array(cumulative_returns) - np.array(cumulative_rf_rates)\n        mean_excess = excess_returns.mean()\n        std_excess = excess_returns.std(ddof=1)\n\n        if np.isclose(std_excess, 0.0):\n            continue\n\n        daily_sharpe = float(mean_excess / std_excess)\n        annual_sharpe = daily_sharpe * np.sqrt(trading_days_per_year)\n\n        result[dt] = (daily_sharpe, annual_sharpe)\n\n    return result\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_sharpe_ratio_by_day_rolling_window_advanced","title":"<code>calculate_sharpe_ratio_by_day_rolling_window_advanced(portfolio, target_currency, window_size, rf_manager=None, start_date=None, end_date=None, trading_days_per_year=252)</code>","text":"<p>Calculate rolling window Sharpe ratios for each trading day.</p> <p>For each trading day, calculates the Sharpe ratio using the trailing window_size trading days of returns.</p> <p>Only includes dates where risk-free rate data is available.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>window_size</code> <code>int</code> <p>Number of trailing trading days to use for each calculation.          Common values: 21 (month), 63 (quarter), 252 (year).</p> required <code>rf_manager</code> <code>RiskFreeRateManager | None</code> <p>Risk-free rate manager. If None, uses FRED DTB3.</p> <code>None</code> <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).         If None, uses the earliest transaction date.</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).       If None, uses the latest transaction date.</p> <code>None</code> <code>trading_days_per_year</code> <code>int</code> <p>Trading days per year for annualization (default 252).</p> <code>252</code> <p>Returns:</p> Type Description <code>dict[datetime, Tuple[float, float]]</code> <p>Dictionary mapping each trading day to (daily_sharpe, annual_sharpe).</p> <code>dict[datetime, Tuple[float, float]]</code> <p>Days with insufficient observations (fewer than window_size) are excluded.</p> Source code in <code>src/athena/metrics/sharpe_advanced.py</code> <pre><code>def calculate_sharpe_ratio_by_day_rolling_window_advanced(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    window_size: int,\n    rf_manager: RiskFreeRateManager | None = None,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    trading_days_per_year: int = 252\n) -&gt; dict[datetime, Tuple[float, float]]:\n    \"\"\"\n    Calculate rolling window Sharpe ratios for each trading day.\n\n    For each trading day, calculates the Sharpe ratio using the trailing\n    window_size trading days of returns.\n\n    Only includes dates where risk-free rate data is available.\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        window_size: Number of trailing trading days to use for each calculation.\n                     Common values: 21 (month), 63 (quarter), 252 (year).\n        rf_manager: Risk-free rate manager. If None, uses FRED DTB3.\n        start_date: The start date for the calculation (inclusive).\n                    If None, uses the earliest transaction date.\n        end_date: The end date for the calculation (inclusive).\n                  If None, uses the latest transaction date.\n        trading_days_per_year: Trading days per year for annualization (default 252).\n\n    Returns:\n        Dictionary mapping each trading day to (daily_sharpe, annual_sharpe).\n        Days with insufficient observations (fewer than window_size) are excluded.\n    \"\"\"\n    if window_size &lt; 2:\n        raise ValueError(\"window_size must be at least 2.\")\n\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; 2:\n        return {}\n\n    # Calculate daily returns\n    daily_returns = calculate_daily_returns(portfolio_values)\n\n    if len(daily_returns) &lt; window_size:\n        return {}\n\n    # Determine date range for risk-free rate data\n    return_dates = sorted(daily_returns.keys())\n    min_dt = return_dates[0].date()\n    max_dt = return_dates[-1].date()\n\n    # Create default manager if not provided\n    if rf_manager is None:\n        rf_manager = _get_default_risk_free_manager(min_dt, max_dt)\n\n    # Align returns with risk-free rates (trading days only)\n    aligned_returns, aligned_rf_rates, aligned_dates = align_returns_with_risk_free_rates(\n        daily_returns,\n        rf_manager,\n        trading_days_per_year\n    )\n\n    if len(aligned_returns) &lt; window_size:\n        return {}\n\n    # Calculate rolling Sharpe for each trading day\n    result: dict[datetime, Tuple[float, float]] = {}\n\n    for i in range(window_size - 1, len(aligned_dates)):\n        window_returns = aligned_returns[i - window_size + 1:i + 1]\n        window_rf_rates = aligned_rf_rates[i - window_size + 1:i + 1]\n        dt = aligned_dates[i]\n\n        excess_returns = np.array(window_returns) - np.array(window_rf_rates)\n        mean_excess = excess_returns.mean()\n        std_excess = excess_returns.std(ddof=1)\n\n        if np.isclose(std_excess, 0.0):\n            continue\n\n        daily_sharpe = float(mean_excess / std_excess)\n        annual_sharpe = daily_sharpe * np.sqrt(trading_days_per_year)\n\n        result[dt] = (daily_sharpe, annual_sharpe)\n\n    return result\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_sharpe_ratio_cumulative_advanced","title":"<code>calculate_sharpe_ratio_cumulative_advanced(portfolio, target_currency, rf_manager=None, start_date=None, end_date=None, trading_days_per_year=252)</code>","text":"<p>Calculate the cumulative Sharpe ratio using dynamic risk-free rates.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>rf_manager</code> <code>RiskFreeRateManager | None</code> <p>Risk-free rate manager. If None, uses FRED DTB3.</p> <code>None</code> <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).         If None, uses the earliest transaction date.</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).       If None, uses the latest transaction date.</p> <code>None</code> <code>trading_days_per_year</code> <code>int</code> <p>Trading days per year for annualization (default 252).</p> <code>252</code> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of (daily_sharpe, annual_sharpe).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If insufficient data or calculation error.</p> Source code in <code>src/athena/metrics/sharpe_advanced.py</code> <pre><code>def calculate_sharpe_ratio_cumulative_advanced(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    rf_manager: RiskFreeRateManager | None = None,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    trading_days_per_year: int = 252\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Calculate the cumulative Sharpe ratio using dynamic risk-free rates.\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        rf_manager: Risk-free rate manager. If None, uses FRED DTB3.\n        start_date: The start date for the calculation (inclusive).\n                    If None, uses the earliest transaction date.\n        end_date: The end date for the calculation (inclusive).\n                  If None, uses the latest transaction date.\n        trading_days_per_year: Trading days per year for annualization (default 252).\n\n    Returns:\n        Tuple of (daily_sharpe, annual_sharpe).\n\n    Raises:\n        ValueError: If insufficient data or calculation error.\n    \"\"\"\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; 2:\n        raise ValueError(\"Need at least two portfolio value observations.\")\n\n    # Calculate daily returns\n    daily_returns = calculate_daily_returns(portfolio_values)\n\n    if len(daily_returns) &lt; 2:\n        raise ValueError(\"Need at least two return observations.\")\n\n    # Determine date range for risk-free rate data\n    return_dates = sorted(daily_returns.keys())\n    min_date = return_dates[0].date()\n    max_date = return_dates[-1].date()\n\n    # Create default manager if not provided\n    if rf_manager is None:\n        rf_manager = _get_default_risk_free_manager(min_date, max_date)\n\n    # Align returns with risk-free rates (trading days only)\n    aligned_returns, aligned_rf_rates, _ = align_returns_with_risk_free_rates(\n        daily_returns,\n        rf_manager,\n        trading_days_per_year\n    )\n\n    if len(aligned_returns) &lt; 2:\n        raise ValueError(\n            \"Need at least two aligned observations after filtering to trading days.\"\n        )\n\n    return calculate_sharpe_ratio_advanced(\n        aligned_returns,\n        aligned_rf_rates,\n        trading_days_per_year\n    )\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_sharpe_ratio_from_values_advanced","title":"<code>calculate_sharpe_ratio_from_values_advanced(portfolio_values, rf_manager=None, trading_days_per_year=252)</code>","text":"<p>Calculate Sharpe ratios directly from portfolio values using dynamic RF rates.</p> <p>Convenience function when you already have portfolio values and don't need to calculate them from a Portfolio object.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio_values</code> <code>dict[datetime, Decimal]</code> <p>Dictionary mapping dates to portfolio values.</p> required <code>rf_manager</code> <code>RiskFreeRateManager | None</code> <p>Risk-free rate manager. If None, uses FRED DTB3.</p> <code>None</code> <code>trading_days_per_year</code> <code>int</code> <p>Trading days per year for annualization (default 252).</p> <code>252</code> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of (daily_sharpe, annual_sharpe).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If insufficient data or calculation error.</p> Source code in <code>src/athena/metrics/sharpe_advanced.py</code> <pre><code>def calculate_sharpe_ratio_from_values_advanced(\n    portfolio_values: dict[datetime, Decimal],\n    rf_manager: RiskFreeRateManager | None = None,\n    trading_days_per_year: int = 252\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Calculate Sharpe ratios directly from portfolio values using dynamic RF rates.\n\n    Convenience function when you already have portfolio values and don't\n    need to calculate them from a Portfolio object.\n\n    Args:\n        portfolio_values: Dictionary mapping dates to portfolio values.\n        rf_manager: Risk-free rate manager. If None, uses FRED DTB3.\n        trading_days_per_year: Trading days per year for annualization (default 252).\n\n    Returns:\n        Tuple of (daily_sharpe, annual_sharpe).\n\n    Raises:\n        ValueError: If insufficient data or calculation error.\n    \"\"\"\n    daily_returns = calculate_daily_returns(portfolio_values)\n\n    if len(daily_returns) &lt; 2:\n        raise ValueError(\"Need at least two return observations.\")\n\n    # Determine date range for risk-free rate data\n    return_dates = sorted(daily_returns.keys())\n    min_date = return_dates[0].date()\n    max_date = return_dates[-1].date()\n\n    # Create default manager if not provided\n    if rf_manager is None:\n        rf_manager = _get_default_risk_free_manager(min_date, max_date)\n\n    # Align returns with risk-free rates\n    aligned_returns, aligned_rf_rates, _ = align_returns_with_risk_free_rates(\n        daily_returns,\n        rf_manager,\n        trading_days_per_year\n    )\n\n    if len(aligned_returns) &lt; 2:\n        raise ValueError(\n            \"Need at least two aligned observations after filtering to trading days.\"\n        )\n\n    return calculate_sharpe_ratio_advanced(\n        aligned_returns,\n        aligned_rf_rates,\n        trading_days_per_year\n    )\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_downside_deviation","title":"<code>calculate_downside_deviation(returns, target_return=0.0)</code>","text":"<p>Calculate downside deviation from a list of returns.</p> <p>Downside deviation measures the volatility of returns that fall below a target return (typically the risk-free rate or zero).</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>list[float]</code> <p>List of returns as decimals (e.g., 0.002 = 0.2%).</p> required <code>target_return</code> <code>float</code> <p>The minimum acceptable return (default 0.0).</p> <code>0.0</code> <p>Returns:</p> Type Description <code>float</code> <p>The downside deviation as a float.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two observations.</p> Source code in <code>src/athena/metrics/sortino.py</code> <pre><code>def calculate_downside_deviation(\n    returns: list[float],\n    target_return: float = 0.0\n) -&gt; float:\n    \"\"\"\n    Calculate downside deviation from a list of returns.\n\n    Downside deviation measures the volatility of returns that fall below\n    a target return (typically the risk-free rate or zero).\n\n    Args:\n        returns: List of returns as decimals (e.g., 0.002 = 0.2%).\n        target_return: The minimum acceptable return (default 0.0).\n\n    Returns:\n        The downside deviation as a float.\n\n    Raises:\n        ValueError: If fewer than two observations.\n    \"\"\"\n    if len(returns) &lt; 2:\n        raise ValueError(\"Need at least two return observations.\")\n\n    returns_array = np.array(returns, dtype=float)\n    downside_returns = np.minimum(returns_array - target_return, 0.0)\n    downside_deviation = np.sqrt(np.mean(downside_returns ** 2))\n\n    return float(downside_deviation)\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_sortino_ratio","title":"<code>calculate_sortino_ratio(returns, annual_risk_free_rate, periods_in_year=365)</code>","text":"<p>Calculate daily and annualized Sortino ratios from a list of returns.</p> <p>The Sortino ratio is similar to the Sharpe ratio but only considers downside volatility, making it a better measure for investors who are primarily concerned with downside risk.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>list[float]</code> <p>List of daily returns as decimals (e.g., 0.002 = 0.2%).</p> required <code>annual_risk_free_rate</code> <code>float</code> <p>Annual nominal risk-free rate (e.g., 0.03 for 3%).</p> required <code>periods_in_year</code> <code>int</code> <p>Trading periods in a year (365 for daily).</p> <code>365</code> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of (daily_sortino, annual_sortino).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two observations or zero downside deviation.</p> Source code in <code>src/athena/metrics/sortino.py</code> <pre><code>def calculate_sortino_ratio(\n    returns: list[float],\n    annual_risk_free_rate: float,\n    periods_in_year: int = 365\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Calculate daily and annualized Sortino ratios from a list of returns.\n\n    The Sortino ratio is similar to the Sharpe ratio but only considers\n    downside volatility, making it a better measure for investors who\n    are primarily concerned with downside risk.\n\n    Args:\n        returns: List of daily returns as decimals (e.g., 0.002 = 0.2%).\n        annual_risk_free_rate: Annual nominal risk-free rate (e.g., 0.03 for 3%).\n        periods_in_year: Trading periods in a year (365 for daily).\n\n    Returns:\n        Tuple of (daily_sortino, annual_sortino).\n\n    Raises:\n        ValueError: If fewer than two observations or zero downside deviation.\n    \"\"\"\n    if len(returns) &lt; 2:\n        raise ValueError(\"Need at least two return observations.\")\n\n    daily_rf = annual_risk_free_rate / periods_in_year\n\n    returns_array = np.array(returns, dtype=float)\n    mean_return = returns_array.mean()\n    excess_return = mean_return - daily_rf\n\n    downside_deviation = calculate_downside_deviation(returns, daily_rf)\n\n    if np.isclose(downside_deviation, 0.0):\n        raise ValueError(\"Downside deviation is zero; Sortino is undefined.\")\n\n    daily_sortino = float(excess_return / downside_deviation)\n    annual_sortino = daily_sortino * np.sqrt(periods_in_year)\n\n    return daily_sortino, annual_sortino\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_sortino_ratio_by_day_cumulative","title":"<code>calculate_sortino_ratio_by_day_cumulative(portfolio, target_currency, annual_risk_free_rate, start_date=None, end_date=None, periods_in_year=365, min_observations=2)</code>","text":"<p>Calculate cumulative Sortino ratios for each day in a date range.</p> <p>For each day, calculates the Sortino ratio using all returns from start_date up to that day (cumulative/expanding window).</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>annual_risk_free_rate</code> <code>float</code> <p>Annual nominal risk-free rate (e.g., 0.03 for 3%).</p> required <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).         If None, uses the earliest transaction date.</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).       If None, uses the latest transaction date.</p> <code>None</code> <code>periods_in_year</code> <code>int</code> <p>Trading periods in a year (365 for daily, 252 for              US equities trading days).</p> <code>365</code> <code>min_observations</code> <code>int</code> <p>Minimum number of return observations required               before calculating Sortino. Defaults to 2.</p> <code>2</code> <p>Returns:</p> Type Description <code>dict[datetime, Tuple[float, float]]</code> <p>Dictionary mapping each date to a tuple of (daily_sortino, annual_sortino).</p> <code>dict[datetime, Tuple[float, float]]</code> <p>Days with insufficient observations are excluded.</p> Source code in <code>src/athena/metrics/sortino.py</code> <pre><code>def calculate_sortino_ratio_by_day_cumulative(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    annual_risk_free_rate: float,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    periods_in_year: int = 365,\n    min_observations: int = 2\n) -&gt; dict[datetime, Tuple[float, float]]:\n    \"\"\"\n    Calculate cumulative Sortino ratios for each day in a date range.\n\n    For each day, calculates the Sortino ratio using all returns from\n    start_date up to that day (cumulative/expanding window).\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        annual_risk_free_rate: Annual nominal risk-free rate (e.g., 0.03 for 3%).\n        start_date: The start date for the calculation (inclusive).\n                    If None, uses the earliest transaction date.\n        end_date: The end date for the calculation (inclusive).\n                  If None, uses the latest transaction date.\n        periods_in_year: Trading periods in a year (365 for daily, 252 for\n                         US equities trading days).\n        min_observations: Minimum number of return observations required\n                          before calculating Sortino. Defaults to 2.\n\n    Returns:\n        Dictionary mapping each date to a tuple of (daily_sortino, annual_sortino).\n        Days with insufficient observations are excluded.\n    \"\"\"\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; 2:\n        return {}\n\n    # Calculate daily returns\n    daily_returns = calculate_daily_returns(portfolio_values)\n\n    if len(daily_returns) &lt; min_observations:\n        return {}\n\n    # Calculate cumulative Sortino for each day\n    sorted_dates = sorted(daily_returns.keys())\n    daily_rf = annual_risk_free_rate / periods_in_year\n\n    result: dict[datetime, Tuple[float, float]] = {}\n    cumulative_returns: list[float] = []\n\n    for date in sorted_dates:\n        cumulative_returns.append(daily_returns[date])\n\n        if len(cumulative_returns) &lt; min_observations:\n            continue\n\n        returns_array = np.array(cumulative_returns, dtype=float)\n        mean_return = returns_array.mean()\n        excess_return = mean_return - daily_rf\n\n        downside_returns = np.minimum(returns_array - daily_rf, 0.0)\n        downside_deviation = np.sqrt(np.mean(downside_returns ** 2))\n\n        if np.isclose(downside_deviation, 0.0):\n            # Skip days where downside deviation is zero\n            continue\n\n        daily_sortino = float(excess_return / downside_deviation)\n        annual_sortino = daily_sortino * np.sqrt(periods_in_year)\n\n        result[date] = (daily_sortino, annual_sortino)\n\n    return result\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_sortino_ratio_by_day_rolling_window","title":"<code>calculate_sortino_ratio_by_day_rolling_window(portfolio, target_currency, annual_risk_free_rate, window_size, start_date=None, end_date=None, periods_in_year=365)</code>","text":"<p>Calculate rolling window Sortino ratios for each day in a date range.</p> <p>For each day, calculates the Sortino ratio using the trailing window_size days of returns.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>annual_risk_free_rate</code> <code>float</code> <p>Annual nominal risk-free rate (e.g., 0.03 for 3%).</p> required <code>window_size</code> <code>int</code> <p>Number of trailing days to use for each calculation.          Common values: 30, 60, 90, 252 (trading year).</p> required <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).         If None, uses the earliest transaction date.</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).       If None, uses the latest transaction date.</p> <code>None</code> <code>periods_in_year</code> <code>int</code> <p>Trading periods in a year (365 for daily, 252 for              US equities trading days).</p> <code>365</code> <p>Returns:</p> Type Description <code>dict[datetime, Tuple[float, float]]</code> <p>Dictionary mapping each date to a tuple of (daily_sortino, annual_sortino).</p> <code>dict[datetime, Tuple[float, float]]</code> <p>Days with insufficient observations (fewer than window_size) are excluded.</p> Source code in <code>src/athena/metrics/sortino.py</code> <pre><code>def calculate_sortino_ratio_by_day_rolling_window(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    annual_risk_free_rate: float,\n    window_size: int,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    periods_in_year: int = 365\n) -&gt; dict[datetime, Tuple[float, float]]:\n    \"\"\"\n    Calculate rolling window Sortino ratios for each day in a date range.\n\n    For each day, calculates the Sortino ratio using the trailing\n    window_size days of returns.\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        annual_risk_free_rate: Annual nominal risk-free rate (e.g., 0.03 for 3%).\n        window_size: Number of trailing days to use for each calculation.\n                     Common values: 30, 60, 90, 252 (trading year).\n        start_date: The start date for the calculation (inclusive).\n                    If None, uses the earliest transaction date.\n        end_date: The end date for the calculation (inclusive).\n                  If None, uses the latest transaction date.\n        periods_in_year: Trading periods in a year (365 for daily, 252 for\n                         US equities trading days).\n\n    Returns:\n        Dictionary mapping each date to a tuple of (daily_sortino, annual_sortino).\n        Days with insufficient observations (fewer than window_size) are excluded.\n    \"\"\"\n    if window_size &lt; 2:\n        raise ValueError(\"window_size must be at least 2.\")\n\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; 2:\n        return {}\n\n    # Calculate daily returns\n    daily_returns = calculate_daily_returns(portfolio_values)\n\n    if len(daily_returns) &lt; window_size:\n        return {}\n\n    # Calculate rolling Sortino for each day\n    sorted_dates = sorted(daily_returns.keys())\n    returns_list = [daily_returns[d] for d in sorted_dates]\n    daily_rf = annual_risk_free_rate / periods_in_year\n\n    result: dict[datetime, Tuple[float, float]] = {}\n\n    for i in range(window_size - 1, len(sorted_dates)):\n        window_returns = returns_list[i - window_size + 1:i + 1]\n        date = sorted_dates[i]\n\n        returns_array = np.array(window_returns, dtype=float)\n        mean_return = returns_array.mean()\n        excess_return = mean_return - daily_rf\n\n        downside_returns = np.minimum(returns_array - daily_rf, 0.0)\n        downside_deviation = np.sqrt(np.mean(downside_returns ** 2))\n\n        if np.isclose(downside_deviation, 0.0):\n            # Skip days where downside deviation is zero\n            continue\n\n        daily_sortino = float(excess_return / downside_deviation)\n        annual_sortino = daily_sortino * np.sqrt(periods_in_year)\n\n        result[date] = (daily_sortino, annual_sortino)\n\n    return result\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_sortino_ratio_cumulative","title":"<code>calculate_sortino_ratio_cumulative(portfolio, target_currency, annual_risk_free_rate, start_date=None, end_date=None, periods_in_year=365)</code>","text":"<p>Calculate the cumulative Sortino ratio for a portfolio over a date range.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>annual_risk_free_rate</code> <code>float</code> <p>Annual nominal risk-free rate (e.g., 0.03 for 3%).</p> required <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).         If None, uses the earliest transaction date.</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).       If None, uses the latest transaction date.</p> <code>None</code> <code>periods_in_year</code> <code>int</code> <p>Trading periods in a year (365 for daily, 252 for              US equities trading days).</p> <code>365</code> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of (daily_sortino, annual_sortino).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two observations or zero downside deviation.</p> Source code in <code>src/athena/metrics/sortino.py</code> <pre><code>def calculate_sortino_ratio_cumulative(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    annual_risk_free_rate: float,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    periods_in_year: int = 365\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Calculate the cumulative Sortino ratio for a portfolio over a date range.\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        annual_risk_free_rate: Annual nominal risk-free rate (e.g., 0.03 for 3%).\n        start_date: The start date for the calculation (inclusive).\n                    If None, uses the earliest transaction date.\n        end_date: The end date for the calculation (inclusive).\n                  If None, uses the latest transaction date.\n        periods_in_year: Trading periods in a year (365 for daily, 252 for\n                         US equities trading days).\n\n    Returns:\n        Tuple of (daily_sortino, annual_sortino).\n\n    Raises:\n        ValueError: If fewer than two observations or zero downside deviation.\n    \"\"\"\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; 2:\n        raise ValueError(\"Need at least two portfolio value observations.\")\n\n    # Calculate daily returns\n    daily_returns = calculate_daily_returns(portfolio_values)\n\n    if len(daily_returns) &lt; 2:\n        raise ValueError(\"Need at least two return observations.\")\n\n    # Calculate Sortino ratio\n    returns_list = [daily_returns[d] for d in sorted(daily_returns.keys())]\n    return calculate_sortino_ratio(returns_list, annual_risk_free_rate, periods_in_year)\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_sortino_ratio_from_values","title":"<code>calculate_sortino_ratio_from_values(portfolio_values, annual_risk_free_rate, periods_in_year=365)</code>","text":"<p>Calculate Sortino ratios directly from a dictionary of portfolio values.</p> <p>This is a convenience function when you already have portfolio values and don't need to calculate them from a Portfolio object.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio_values</code> <code>dict[datetime, Decimal]</code> <p>Dictionary mapping dates to portfolio values.</p> required <code>annual_risk_free_rate</code> <code>float</code> <p>Annual nominal risk-free rate (e.g., 0.03 for 3%).</p> required <code>periods_in_year</code> <code>int</code> <p>Trading periods in a year (365 for daily).</p> <code>365</code> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of (daily_sortino, annual_sortino).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two observations or zero downside deviation.</p> Source code in <code>src/athena/metrics/sortino.py</code> <pre><code>def calculate_sortino_ratio_from_values(\n    portfolio_values: dict[datetime, Decimal],\n    annual_risk_free_rate: float,\n    periods_in_year: int = 365\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Calculate Sortino ratios directly from a dictionary of portfolio values.\n\n    This is a convenience function when you already have portfolio values\n    and don't need to calculate them from a Portfolio object.\n\n    Args:\n        portfolio_values: Dictionary mapping dates to portfolio values.\n        annual_risk_free_rate: Annual nominal risk-free rate (e.g., 0.03 for 3%).\n        periods_in_year: Trading periods in a year (365 for daily).\n\n    Returns:\n        Tuple of (daily_sortino, annual_sortino).\n\n    Raises:\n        ValueError: If fewer than two observations or zero downside deviation.\n    \"\"\"\n    daily_returns = calculate_daily_returns(portfolio_values)\n\n    if len(daily_returns) &lt; 2:\n        raise ValueError(\"Need at least two return observations.\")\n\n    returns_list = [daily_returns[d] for d in sorted(daily_returns.keys())]\n\n    return calculate_sortino_ratio(returns_list, annual_risk_free_rate, periods_in_year)\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_cvar","title":"<code>calculate_cvar(returns, confidence_level=0.95)</code>","text":"<p>Calculate Conditional Value at Risk (Expected Shortfall).</p> <p>CVaR represents the expected loss given that the loss exceeds the VaR threshold. It provides a more complete picture of tail risk than VaR alone.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>list[float]</code> <p>List of daily returns as decimals (e.g., 0.002 = 0.2%).</p> required <code>confidence_level</code> <code>float</code> <p>Confidence level for CVaR (e.g., 0.95 for 95%).</p> <code>0.95</code> <p>Returns:</p> Type Description <code>float</code> <p>CVaR as a negative float representing the expected loss beyond VaR</p> <code>float</code> <p>(e.g., -0.08 means 8% expected loss in worst cases).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two observations or invalid confidence level.</p> Source code in <code>src/athena/metrics/value_at_risk.py</code> <pre><code>def calculate_cvar(\n    returns: list[float],\n    confidence_level: float = 0.95\n) -&gt; float:\n    \"\"\"\n    Calculate Conditional Value at Risk (Expected Shortfall).\n\n    CVaR represents the expected loss given that the loss exceeds the VaR\n    threshold. It provides a more complete picture of tail risk than VaR alone.\n\n    Args:\n        returns: List of daily returns as decimals (e.g., 0.002 = 0.2%).\n        confidence_level: Confidence level for CVaR (e.g., 0.95 for 95%).\n\n    Returns:\n        CVaR as a negative float representing the expected loss beyond VaR\n        (e.g., -0.08 means 8% expected loss in worst cases).\n\n    Raises:\n        ValueError: If fewer than two observations or invalid confidence level.\n    \"\"\"\n    if len(returns) &lt; 2:\n        raise ValueError(\"Need at least two return observations.\")\n\n    if not 0 &lt; confidence_level &lt; 1:\n        raise ValueError(\"Confidence level must be between 0 and 1.\")\n\n    returns_array = np.array(returns, dtype=float)\n    var = calculate_var_historical(returns, confidence_level)\n\n    # CVaR is the mean of returns that are worse than VaR\n    tail_returns = returns_array[returns_array &lt;= var]\n\n    if len(tail_returns) == 0:\n        return var\n\n    return float(tail_returns.mean())\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_var_by_day_cumulative","title":"<code>calculate_var_by_day_cumulative(portfolio, target_currency, confidence_level=0.95, method='historical', start_date=None, end_date=None, min_observations=30)</code>","text":"<p>Calculate cumulative Value at Risk for each day in a date range.</p> <p>For each day, calculates VaR using all returns from start_date up to that day (cumulative/expanding window).</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>confidence_level</code> <code>float</code> <p>Confidence level for VaR (e.g., 0.95 for 95%).</p> <code>0.95</code> <code>method</code> <code>str</code> <p>VaR calculation method (\"historical\" or \"parametric\").</p> <code>'historical'</code> <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).         If None, uses the earliest transaction date.</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).       If None, uses the latest transaction date.</p> <code>None</code> <code>min_observations</code> <code>int</code> <p>Minimum number of return observations required               before calculating VaR. Defaults to 30.</p> <code>30</code> <p>Returns:</p> Type Description <code>dict[datetime, float]</code> <p>Dictionary mapping each date to the cumulative VaR up to that date.</p> <code>dict[datetime, float]</code> <p>Days with insufficient observations are excluded.</p> Source code in <code>src/athena/metrics/value_at_risk.py</code> <pre><code>def calculate_var_by_day_cumulative(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    confidence_level: float = 0.95,\n    method: str = \"historical\",\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    min_observations: int = 30\n) -&gt; dict[datetime, float]:\n    \"\"\"\n    Calculate cumulative Value at Risk for each day in a date range.\n\n    For each day, calculates VaR using all returns from start_date up to\n    that day (cumulative/expanding window).\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        confidence_level: Confidence level for VaR (e.g., 0.95 for 95%).\n        method: VaR calculation method (\"historical\" or \"parametric\").\n        start_date: The start date for the calculation (inclusive).\n                    If None, uses the earliest transaction date.\n        end_date: The end date for the calculation (inclusive).\n                  If None, uses the latest transaction date.\n        min_observations: Minimum number of return observations required\n                          before calculating VaR. Defaults to 30.\n\n    Returns:\n        Dictionary mapping each date to the cumulative VaR up to that date.\n        Days with insufficient observations are excluded.\n    \"\"\"\n    if method not in (\"historical\", \"parametric\"):\n        raise ValueError(\"Method must be 'historical' or 'parametric'.\")\n\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; 2:\n        return {}\n\n    # Calculate daily returns\n    daily_returns = calculate_daily_returns(portfolio_values)\n\n    if len(daily_returns) &lt; min_observations:\n        return {}\n\n    sorted_dates = sorted(daily_returns.keys())\n    result: dict[datetime, float] = {}\n    cumulative_returns: list[float] = []\n\n    var_func = calculate_var_historical if method == \"historical\" else calculate_var_parametric\n\n    for date in sorted_dates:\n        cumulative_returns.append(daily_returns[date])\n\n        if len(cumulative_returns) &lt; min_observations:\n            continue\n\n        try:\n            var = var_func(cumulative_returns, confidence_level)\n            result[date] = var\n        except ValueError:\n            continue\n\n    return result\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_var_by_day_rolling_window","title":"<code>calculate_var_by_day_rolling_window(portfolio, target_currency, window_size, confidence_level=0.95, method='historical', start_date=None, end_date=None)</code>","text":"<p>Calculate rolling window Value at Risk for each day in a date range.</p> <p>For each day, calculates VaR using the trailing window_size days of returns.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>window_size</code> <code>int</code> <p>Number of trailing days to use for each calculation.          Common values: 30, 60, 90, 252 (trading year).</p> required <code>confidence_level</code> <code>float</code> <p>Confidence level for VaR (e.g., 0.95 for 95%).</p> <code>0.95</code> <code>method</code> <code>str</code> <p>VaR calculation method (\"historical\" or \"parametric\").</p> <code>'historical'</code> <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).         If None, uses the earliest transaction date.</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).       If None, uses the latest transaction date.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[datetime, float]</code> <p>Dictionary mapping each date to the rolling VaR.</p> <code>dict[datetime, float]</code> <p>Days with insufficient observations (fewer than window_size) are excluded.</p> Source code in <code>src/athena/metrics/value_at_risk.py</code> <pre><code>def calculate_var_by_day_rolling_window(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    window_size: int,\n    confidence_level: float = 0.95,\n    method: str = \"historical\",\n    start_date: datetime | None = None,\n    end_date: datetime | None = None\n) -&gt; dict[datetime, float]:\n    \"\"\"\n    Calculate rolling window Value at Risk for each day in a date range.\n\n    For each day, calculates VaR using the trailing window_size days of returns.\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        window_size: Number of trailing days to use for each calculation.\n                     Common values: 30, 60, 90, 252 (trading year).\n        confidence_level: Confidence level for VaR (e.g., 0.95 for 95%).\n        method: VaR calculation method (\"historical\" or \"parametric\").\n        start_date: The start date for the calculation (inclusive).\n                    If None, uses the earliest transaction date.\n        end_date: The end date for the calculation (inclusive).\n                  If None, uses the latest transaction date.\n\n    Returns:\n        Dictionary mapping each date to the rolling VaR.\n        Days with insufficient observations (fewer than window_size) are excluded.\n    \"\"\"\n    if window_size &lt; 2:\n        raise ValueError(\"window_size must be at least 2.\")\n\n    if method not in (\"historical\", \"parametric\"):\n        raise ValueError(\"Method must be 'historical' or 'parametric'.\")\n\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; 2:\n        return {}\n\n    # Calculate daily returns\n    daily_returns = calculate_daily_returns(portfolio_values)\n\n    if len(daily_returns) &lt; window_size:\n        return {}\n\n    sorted_dates = sorted(daily_returns.keys())\n    returns_list = [daily_returns[d] for d in sorted_dates]\n\n    var_func = calculate_var_historical if method == \"historical\" else calculate_var_parametric\n\n    result: dict[datetime, float] = {}\n\n    for i in range(window_size - 1, len(sorted_dates)):\n        window_returns = returns_list[i - window_size + 1:i + 1]\n        date = sorted_dates[i]\n\n        try:\n            var = var_func(window_returns, confidence_level)\n            result[date] = var\n        except ValueError:\n            continue\n\n    return result\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_var_cumulative","title":"<code>calculate_var_cumulative(portfolio, target_currency, confidence_level=0.95, method='historical', start_date=None, end_date=None)</code>","text":"<p>Calculate Value at Risk and CVaR for a portfolio over a date range.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>confidence_level</code> <code>float</code> <p>Confidence level for VaR (e.g., 0.95 for 95%).</p> <code>0.95</code> <code>method</code> <code>str</code> <p>VaR calculation method (\"historical\" or \"parametric\").</p> <code>'historical'</code> <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).         If None, uses the earliest transaction date.</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).       If None, uses the latest transaction date.</p> <code>None</code> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of (var, cvar) as negative floats.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two observations or invalid parameters.</p> Source code in <code>src/athena/metrics/value_at_risk.py</code> <pre><code>def calculate_var_cumulative(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    confidence_level: float = 0.95,\n    method: str = \"historical\",\n    start_date: datetime | None = None,\n    end_date: datetime | None = None\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Calculate Value at Risk and CVaR for a portfolio over a date range.\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        confidence_level: Confidence level for VaR (e.g., 0.95 for 95%).\n        method: VaR calculation method (\"historical\" or \"parametric\").\n        start_date: The start date for the calculation (inclusive).\n                    If None, uses the earliest transaction date.\n        end_date: The end date for the calculation (inclusive).\n                  If None, uses the latest transaction date.\n\n    Returns:\n        Tuple of (var, cvar) as negative floats.\n\n    Raises:\n        ValueError: If fewer than two observations or invalid parameters.\n    \"\"\"\n    if method not in (\"historical\", \"parametric\"):\n        raise ValueError(\"Method must be 'historical' or 'parametric'.\")\n\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; 2:\n        raise ValueError(\"Need at least two portfolio value observations.\")\n\n    # Calculate daily returns\n    daily_returns = calculate_daily_returns(portfolio_values)\n\n    if len(daily_returns) &lt; 2:\n        raise ValueError(\"Need at least two return observations.\")\n\n    returns_list = [daily_returns[d] for d in sorted(daily_returns.keys())]\n\n    var_func = calculate_var_historical if method == \"historical\" else calculate_var_parametric\n    var = var_func(returns_list, confidence_level)\n    cvar = calculate_cvar(returns_list, confidence_level)\n\n    return var, cvar\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_var_from_values","title":"<code>calculate_var_from_values(portfolio_values, confidence_level=0.95, method='historical')</code>","text":"<p>Calculate VaR and CVaR directly from a dictionary of portfolio values.</p> <p>This is a convenience function when you already have portfolio values and don't need to calculate them from a Portfolio object.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio_values</code> <code>dict[datetime, Decimal]</code> <p>Dictionary mapping dates to portfolio values.</p> required <code>confidence_level</code> <code>float</code> <p>Confidence level for VaR (e.g., 0.95 for 95%).</p> <code>0.95</code> <code>method</code> <code>str</code> <p>VaR calculation method (\"historical\" or \"parametric\").</p> <code>'historical'</code> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of (var, cvar) as negative floats.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two observations or invalid parameters.</p> Source code in <code>src/athena/metrics/value_at_risk.py</code> <pre><code>def calculate_var_from_values(\n    portfolio_values: dict[datetime, Decimal],\n    confidence_level: float = 0.95,\n    method: str = \"historical\"\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Calculate VaR and CVaR directly from a dictionary of portfolio values.\n\n    This is a convenience function when you already have portfolio values\n    and don't need to calculate them from a Portfolio object.\n\n    Args:\n        portfolio_values: Dictionary mapping dates to portfolio values.\n        confidence_level: Confidence level for VaR (e.g., 0.95 for 95%).\n        method: VaR calculation method (\"historical\" or \"parametric\").\n\n    Returns:\n        Tuple of (var, cvar) as negative floats.\n\n    Raises:\n        ValueError: If fewer than two observations or invalid parameters.\n    \"\"\"\n    if method not in (\"historical\", \"parametric\"):\n        raise ValueError(\"Method must be 'historical' or 'parametric'.\")\n\n    daily_returns = calculate_daily_returns(portfolio_values)\n\n    if len(daily_returns) &lt; 2:\n        raise ValueError(\"Need at least two return observations.\")\n\n    returns_list = [daily_returns[d] for d in sorted(daily_returns.keys())]\n\n    var_func = calculate_var_historical if method == \"historical\" else calculate_var_parametric\n    var = var_func(returns_list, confidence_level)\n    cvar = calculate_cvar(returns_list, confidence_level)\n\n    return var, cvar\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_var_historical","title":"<code>calculate_var_historical(returns, confidence_level=0.95)</code>","text":"<p>Calculate Value at Risk using the historical simulation method.</p> <p>Historical VaR uses the actual distribution of past returns to estimate potential losses at a given confidence level.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>list[float]</code> <p>List of daily returns as decimals (e.g., 0.002 = 0.2%).</p> required <code>confidence_level</code> <code>float</code> <p>Confidence level for VaR (e.g., 0.95 for 95%).</p> <code>0.95</code> <p>Returns:</p> Type Description <code>float</code> <p>VaR as a negative float representing the potential loss</p> <code>float</code> <p>(e.g., -0.05 means 5% potential loss at the given confidence level).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two observations or invalid confidence level.</p> Source code in <code>src/athena/metrics/value_at_risk.py</code> <pre><code>def calculate_var_historical(\n    returns: list[float],\n    confidence_level: float = 0.95\n) -&gt; float:\n    \"\"\"\n    Calculate Value at Risk using the historical simulation method.\n\n    Historical VaR uses the actual distribution of past returns to estimate\n    potential losses at a given confidence level.\n\n    Args:\n        returns: List of daily returns as decimals (e.g., 0.002 = 0.2%).\n        confidence_level: Confidence level for VaR (e.g., 0.95 for 95%).\n\n    Returns:\n        VaR as a negative float representing the potential loss\n        (e.g., -0.05 means 5% potential loss at the given confidence level).\n\n    Raises:\n        ValueError: If fewer than two observations or invalid confidence level.\n    \"\"\"\n    if len(returns) &lt; 2:\n        raise ValueError(\"Need at least two return observations.\")\n\n    if not 0 &lt; confidence_level &lt; 1:\n        raise ValueError(\"Confidence level must be between 0 and 1.\")\n\n    returns_array = np.array(returns, dtype=float)\n    var = float(np.percentile(returns_array, (1 - confidence_level) * 100))\n\n    return var\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_var_parametric","title":"<code>calculate_var_parametric(returns, confidence_level=0.95)</code>","text":"<p>Calculate Value at Risk using the parametric (variance-covariance) method.</p> <p>Parametric VaR assumes returns are normally distributed and uses the mean and standard deviation to estimate potential losses.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>list[float]</code> <p>List of daily returns as decimals (e.g., 0.002 = 0.2%).</p> required <code>confidence_level</code> <code>float</code> <p>Confidence level for VaR (e.g., 0.95 for 95%).</p> <code>0.95</code> <p>Returns:</p> Type Description <code>float</code> <p>VaR as a negative float representing the potential loss</p> <code>float</code> <p>(e.g., -0.05 means 5% potential loss at the given confidence level).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two observations or invalid confidence level.</p> Source code in <code>src/athena/metrics/value_at_risk.py</code> <pre><code>def calculate_var_parametric(\n    returns: list[float],\n    confidence_level: float = 0.95\n) -&gt; float:\n    \"\"\"\n    Calculate Value at Risk using the parametric (variance-covariance) method.\n\n    Parametric VaR assumes returns are normally distributed and uses the\n    mean and standard deviation to estimate potential losses.\n\n    Args:\n        returns: List of daily returns as decimals (e.g., 0.002 = 0.2%).\n        confidence_level: Confidence level for VaR (e.g., 0.95 for 95%).\n\n    Returns:\n        VaR as a negative float representing the potential loss\n        (e.g., -0.05 means 5% potential loss at the given confidence level).\n\n    Raises:\n        ValueError: If fewer than two observations or invalid confidence level.\n    \"\"\"\n    if len(returns) &lt; 2:\n        raise ValueError(\"Need at least two return observations.\")\n\n    if not 0 &lt; confidence_level &lt; 1:\n        raise ValueError(\"Confidence level must be between 0 and 1.\")\n\n    returns_array = np.array(returns, dtype=float)\n    mean_return = returns_array.mean()\n    std_return = returns_array.std(ddof=1)\n\n    # Get the z-score for the confidence level\n    z_score = stats.norm.ppf(1 - confidence_level)\n    var = float(mean_return + z_score * std_return)\n\n    return var\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_downside_volatility","title":"<code>calculate_downside_volatility(returns, periods_in_year=365)</code>","text":"<p>Calculate downside volatility (volatility of negative returns only).</p> <p>Downside volatility measures the dispersion of returns below zero, capturing the variability of losses.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>list[float]</code> <p>List of daily returns as decimals (e.g., 0.002 = 0.2%).</p> required <code>periods_in_year</code> <code>int</code> <p>Trading periods in a year (365 for daily).</p> <code>365</code> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of (daily_downside_volatility, annual_downside_volatility).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two negative return observations.</p> Source code in <code>src/athena/metrics/volatility.py</code> <pre><code>def calculate_downside_volatility(\n    returns: list[float],\n    periods_in_year: int = 365\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Calculate downside volatility (volatility of negative returns only).\n\n    Downside volatility measures the dispersion of returns below zero,\n    capturing the variability of losses.\n\n    Args:\n        returns: List of daily returns as decimals (e.g., 0.002 = 0.2%).\n        periods_in_year: Trading periods in a year (365 for daily).\n\n    Returns:\n        Tuple of (daily_downside_volatility, annual_downside_volatility).\n\n    Raises:\n        ValueError: If fewer than two negative return observations.\n    \"\"\"\n    negative_returns = [r for r in returns if r &lt; 0]\n\n    if len(negative_returns) &lt; 2:\n        raise ValueError(\"Need at least two negative return observations.\")\n\n    returns_array = np.array(negative_returns, dtype=float)\n    daily_volatility = float(returns_array.std(ddof=1))\n    annual_volatility = daily_volatility * np.sqrt(periods_in_year)\n\n    return daily_volatility, annual_volatility\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_upside_volatility","title":"<code>calculate_upside_volatility(returns, periods_in_year=365)</code>","text":"<p>Calculate upside volatility (volatility of positive returns only).</p> <p>Upside volatility measures the dispersion of returns above zero, capturing the variability of gains.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>list[float]</code> <p>List of daily returns as decimals (e.g., 0.002 = 0.2%).</p> required <code>periods_in_year</code> <code>int</code> <p>Trading periods in a year (365 for daily).</p> <code>365</code> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of (daily_upside_volatility, annual_upside_volatility).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two positive return observations.</p> Source code in <code>src/athena/metrics/volatility.py</code> <pre><code>def calculate_upside_volatility(\n    returns: list[float],\n    periods_in_year: int = 365\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Calculate upside volatility (volatility of positive returns only).\n\n    Upside volatility measures the dispersion of returns above zero,\n    capturing the variability of gains.\n\n    Args:\n        returns: List of daily returns as decimals (e.g., 0.002 = 0.2%).\n        periods_in_year: Trading periods in a year (365 for daily).\n\n    Returns:\n        Tuple of (daily_upside_volatility, annual_upside_volatility).\n\n    Raises:\n        ValueError: If fewer than two positive return observations.\n    \"\"\"\n    positive_returns = [r for r in returns if r &gt; 0]\n\n    if len(positive_returns) &lt; 2:\n        raise ValueError(\"Need at least two positive return observations.\")\n\n    returns_array = np.array(positive_returns, dtype=float)\n    daily_volatility = float(returns_array.std(ddof=1))\n    annual_volatility = daily_volatility * np.sqrt(periods_in_year)\n\n    return daily_volatility, annual_volatility\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_volatility","title":"<code>calculate_volatility(returns, periods_in_year=365)</code>","text":"<p>Calculate daily and annualized volatility from a list of returns.</p> <p>Volatility is measured as the standard deviation of returns, which quantifies the dispersion of returns around their mean.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>list[float]</code> <p>List of daily returns as decimals (e.g., 0.002 = 0.2%).</p> required <code>periods_in_year</code> <code>int</code> <p>Trading periods in a year (365 for daily).</p> <code>365</code> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of (daily_volatility, annual_volatility).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two observations.</p> Source code in <code>src/athena/metrics/volatility.py</code> <pre><code>def calculate_volatility(\n    returns: list[float],\n    periods_in_year: int = 365\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Calculate daily and annualized volatility from a list of returns.\n\n    Volatility is measured as the standard deviation of returns, which\n    quantifies the dispersion of returns around their mean.\n\n    Args:\n        returns: List of daily returns as decimals (e.g., 0.002 = 0.2%).\n        periods_in_year: Trading periods in a year (365 for daily).\n\n    Returns:\n        Tuple of (daily_volatility, annual_volatility).\n\n    Raises:\n        ValueError: If fewer than two observations.\n    \"\"\"\n    if len(returns) &lt; 2:\n        raise ValueError(\"Need at least two return observations.\")\n\n    returns_array = np.array(returns, dtype=float)\n    daily_volatility = float(returns_array.std(ddof=1))\n    annual_volatility = daily_volatility * np.sqrt(periods_in_year)\n\n    return daily_volatility, annual_volatility\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_volatility_by_day_cumulative","title":"<code>calculate_volatility_by_day_cumulative(portfolio, target_currency, start_date=None, end_date=None, periods_in_year=365, min_observations=2)</code>","text":"<p>Calculate cumulative volatility for each day in a date range.</p> <p>For each day, calculates the volatility using all returns from start_date up to that day (cumulative/expanding window).</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).         If None, uses the earliest transaction date.</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).       If None, uses the latest transaction date.</p> <code>None</code> <code>periods_in_year</code> <code>int</code> <p>Trading periods in a year (365 for daily, 252 for              US equities trading days).</p> <code>365</code> <code>min_observations</code> <code>int</code> <p>Minimum number of return observations required               before calculating volatility. Defaults to 2.</p> <code>2</code> <p>Returns:</p> Type Description <code>dict[datetime, Tuple[float, float]]</code> <p>Dictionary mapping each date to a tuple of (daily_volatility, annual_volatility).</p> <code>dict[datetime, Tuple[float, float]]</code> <p>Days with insufficient observations are excluded.</p> Source code in <code>src/athena/metrics/volatility.py</code> <pre><code>def calculate_volatility_by_day_cumulative(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    periods_in_year: int = 365,\n    min_observations: int = 2\n) -&gt; dict[datetime, Tuple[float, float]]:\n    \"\"\"\n    Calculate cumulative volatility for each day in a date range.\n\n    For each day, calculates the volatility using all returns from\n    start_date up to that day (cumulative/expanding window).\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        start_date: The start date for the calculation (inclusive).\n                    If None, uses the earliest transaction date.\n        end_date: The end date for the calculation (inclusive).\n                  If None, uses the latest transaction date.\n        periods_in_year: Trading periods in a year (365 for daily, 252 for\n                         US equities trading days).\n        min_observations: Minimum number of return observations required\n                          before calculating volatility. Defaults to 2.\n\n    Returns:\n        Dictionary mapping each date to a tuple of (daily_volatility, annual_volatility).\n        Days with insufficient observations are excluded.\n    \"\"\"\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; 2:\n        return {}\n\n    # Calculate daily returns\n    daily_returns = calculate_daily_returns(portfolio_values)\n\n    if len(daily_returns) &lt; min_observations:\n        return {}\n\n    sorted_dates = sorted(daily_returns.keys())\n    result: dict[datetime, Tuple[float, float]] = {}\n    cumulative_returns: list[float] = []\n\n    for date in sorted_dates:\n        cumulative_returns.append(daily_returns[date])\n\n        if len(cumulative_returns) &lt; min_observations:\n            continue\n\n        returns_array = np.array(cumulative_returns, dtype=float)\n        daily_volatility = float(returns_array.std(ddof=1))\n        annual_volatility = daily_volatility * np.sqrt(periods_in_year)\n\n        result[date] = (daily_volatility, annual_volatility)\n\n    return result\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_volatility_by_day_rolling_window","title":"<code>calculate_volatility_by_day_rolling_window(portfolio, target_currency, window_size, start_date=None, end_date=None, periods_in_year=365)</code>","text":"<p>Calculate rolling window volatility for each day in a date range.</p> <p>For each day, calculates the volatility using the trailing window_size days of returns.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>window_size</code> <code>int</code> <p>Number of trailing days to use for each calculation.          Common values: 20, 30, 60, 90.</p> required <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).         If None, uses the earliest transaction date.</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).       If None, uses the latest transaction date.</p> <code>None</code> <code>periods_in_year</code> <code>int</code> <p>Trading periods in a year (365 for daily, 252 for              US equities trading days).</p> <code>365</code> <p>Returns:</p> Type Description <code>dict[datetime, Tuple[float, float]]</code> <p>Dictionary mapping each date to a tuple of (daily_volatility, annual_volatility).</p> <code>dict[datetime, Tuple[float, float]]</code> <p>Days with insufficient observations (fewer than window_size) are excluded.</p> Source code in <code>src/athena/metrics/volatility.py</code> <pre><code>def calculate_volatility_by_day_rolling_window(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    window_size: int,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    periods_in_year: int = 365\n) -&gt; dict[datetime, Tuple[float, float]]:\n    \"\"\"\n    Calculate rolling window volatility for each day in a date range.\n\n    For each day, calculates the volatility using the trailing\n    window_size days of returns.\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        window_size: Number of trailing days to use for each calculation.\n                     Common values: 20, 30, 60, 90.\n        start_date: The start date for the calculation (inclusive).\n                    If None, uses the earliest transaction date.\n        end_date: The end date for the calculation (inclusive).\n                  If None, uses the latest transaction date.\n        periods_in_year: Trading periods in a year (365 for daily, 252 for\n                         US equities trading days).\n\n    Returns:\n        Dictionary mapping each date to a tuple of (daily_volatility, annual_volatility).\n        Days with insufficient observations (fewer than window_size) are excluded.\n    \"\"\"\n    if window_size &lt; 2:\n        raise ValueError(\"window_size must be at least 2.\")\n\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; 2:\n        return {}\n\n    # Calculate daily returns\n    daily_returns = calculate_daily_returns(portfolio_values)\n\n    if len(daily_returns) &lt; window_size:\n        return {}\n\n    sorted_dates = sorted(daily_returns.keys())\n    returns_list = [daily_returns[d] for d in sorted_dates]\n\n    result: dict[datetime, Tuple[float, float]] = {}\n\n    for i in range(window_size - 1, len(sorted_dates)):\n        window_returns = returns_list[i - window_size + 1:i + 1]\n        date = sorted_dates[i]\n\n        returns_array = np.array(window_returns, dtype=float)\n        daily_volatility = float(returns_array.std(ddof=1))\n        annual_volatility = daily_volatility * np.sqrt(periods_in_year)\n\n        result[date] = (daily_volatility, annual_volatility)\n\n    return result\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_volatility_cumulative","title":"<code>calculate_volatility_cumulative(portfolio, target_currency, start_date=None, end_date=None, periods_in_year=365)</code>","text":"<p>Calculate the volatility for a portfolio over a date range.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).         If None, uses the earliest transaction date.</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).       If None, uses the latest transaction date.</p> <code>None</code> <code>periods_in_year</code> <code>int</code> <p>Trading periods in a year (365 for daily, 252 for              US equities trading days).</p> <code>365</code> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of (daily_volatility, annual_volatility).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two observations.</p> Source code in <code>src/athena/metrics/volatility.py</code> <pre><code>def calculate_volatility_cumulative(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    periods_in_year: int = 365\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Calculate the volatility for a portfolio over a date range.\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        start_date: The start date for the calculation (inclusive).\n                    If None, uses the earliest transaction date.\n        end_date: The end date for the calculation (inclusive).\n                  If None, uses the latest transaction date.\n        periods_in_year: Trading periods in a year (365 for daily, 252 for\n                         US equities trading days).\n\n    Returns:\n        Tuple of (daily_volatility, annual_volatility).\n\n    Raises:\n        ValueError: If fewer than two observations.\n    \"\"\"\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; 2:\n        raise ValueError(\"Need at least two portfolio value observations.\")\n\n    # Calculate daily returns\n    daily_returns = calculate_daily_returns(portfolio_values)\n\n    if len(daily_returns) &lt; 2:\n        raise ValueError(\"Need at least two return observations.\")\n\n    returns_list = [daily_returns[d] for d in sorted(daily_returns.keys())]\n    return calculate_volatility(returns_list, periods_in_year)\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_volatility_from_values","title":"<code>calculate_volatility_from_values(portfolio_values, periods_in_year=365)</code>","text":"<p>Calculate volatility directly from a dictionary of portfolio values.</p> <p>This is a convenience function when you already have portfolio values and don't need to calculate them from a Portfolio object.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio_values</code> <code>dict[datetime, Decimal]</code> <p>Dictionary mapping dates to portfolio values.</p> required <code>periods_in_year</code> <code>int</code> <p>Trading periods in a year (365 for daily).</p> <code>365</code> <p>Returns:</p> Type Description <code>Tuple[float, float]</code> <p>Tuple of (daily_volatility, annual_volatility).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If fewer than two observations.</p> Source code in <code>src/athena/metrics/volatility.py</code> <pre><code>def calculate_volatility_from_values(\n    portfolio_values: dict[datetime, Decimal],\n    periods_in_year: int = 365\n) -&gt; Tuple[float, float]:\n    \"\"\"\n    Calculate volatility directly from a dictionary of portfolio values.\n\n    This is a convenience function when you already have portfolio values\n    and don't need to calculate them from a Portfolio object.\n\n    Args:\n        portfolio_values: Dictionary mapping dates to portfolio values.\n        periods_in_year: Trading periods in a year (365 for daily).\n\n    Returns:\n        Tuple of (daily_volatility, annual_volatility).\n\n    Raises:\n        ValueError: If fewer than two observations.\n    \"\"\"\n    daily_returns = calculate_daily_returns(portfolio_values)\n\n    if len(daily_returns) &lt; 2:\n        raise ValueError(\"Need at least two return observations.\")\n\n    returns_list = [daily_returns[d] for d in sorted(daily_returns.keys())]\n    return calculate_volatility(returns_list, periods_in_year)\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_volatility_ratio","title":"<code>calculate_volatility_ratio(returns)</code>","text":"<p>Calculate the ratio of downside to upside volatility.</p> <p>A ratio greater than 1 indicates more variability in losses than gains. A ratio less than 1 indicates more variability in gains than losses.</p> <p>Parameters:</p> Name Type Description Default <code>returns</code> <code>list[float]</code> <p>List of daily returns as decimals (e.g., 0.002 = 0.2%).</p> required <p>Returns:</p> Type Description <code>float | None</code> <p>The volatility ratio (downside/upside), or None if insufficient data.</p> Source code in <code>src/athena/metrics/volatility.py</code> <pre><code>def calculate_volatility_ratio(\n    returns: list[float]\n) -&gt; float | None:\n    \"\"\"\n    Calculate the ratio of downside to upside volatility.\n\n    A ratio greater than 1 indicates more variability in losses than gains.\n    A ratio less than 1 indicates more variability in gains than losses.\n\n    Args:\n        returns: List of daily returns as decimals (e.g., 0.002 = 0.2%).\n\n    Returns:\n        The volatility ratio (downside/upside), or None if insufficient data.\n    \"\"\"\n    positive_returns = [r for r in returns if r &gt; 0]\n    negative_returns = [r for r in returns if r &lt; 0]\n\n    if len(positive_returns) &lt; 2 or len(negative_returns) &lt; 2:\n        return None\n\n    upside_std = np.array(positive_returns, dtype=float).std(ddof=1)\n    downside_std = np.array(negative_returns, dtype=float).std(ddof=1)\n\n    if np.isclose(upside_std, 0.0):\n        return None\n\n    return float(downside_std / upside_std)\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_volatility_statistics","title":"<code>calculate_volatility_statistics(portfolio, target_currency, start_date=None, end_date=None, periods_in_year=365)</code>","text":"<p>Calculate comprehensive volatility statistics for a portfolio.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions and settings.</p> required <code>target_currency</code> <code>Currency</code> <p>The currency to convert all values into.</p> required <code>start_date</code> <code>datetime | None</code> <p>The start date for the calculation (inclusive).         If None, uses the earliest transaction date.</p> <code>None</code> <code>end_date</code> <code>datetime | None</code> <p>The end date for the calculation (inclusive).       If None, uses the latest transaction date.</p> <code>None</code> <code>periods_in_year</code> <code>int</code> <p>Trading periods in a year (365 for daily).</p> <code>365</code> <p>Returns:</p> Type Description <code>dict[str, float | None]</code> <p>Dictionary containing:</p> <code>dict[str, float | None]</code> <ul> <li>daily_volatility: Daily standard deviation of returns</li> </ul> <code>dict[str, float | None]</code> <ul> <li>annual_volatility: Annualized standard deviation</li> </ul> <code>dict[str, float | None]</code> <ul> <li>daily_upside_volatility: Daily std of positive returns (or None)</li> </ul> <code>dict[str, float | None]</code> <ul> <li>annual_upside_volatility: Annualized std of positive returns (or None)</li> </ul> <code>dict[str, float | None]</code> <ul> <li>daily_downside_volatility: Daily std of negative returns (or None)</li> </ul> <code>dict[str, float | None]</code> <ul> <li>annual_downside_volatility: Annualized std of negative returns (or None)</li> </ul> <code>dict[str, float | None]</code> <ul> <li>volatility_ratio: Downside/upside volatility ratio (or None)</li> </ul> Source code in <code>src/athena/metrics/volatility.py</code> <pre><code>def calculate_volatility_statistics(\n    portfolio: Portfolio,\n    target_currency: Currency,\n    start_date: datetime | None = None,\n    end_date: datetime | None = None,\n    periods_in_year: int = 365\n) -&gt; dict[str, float | None]:\n    \"\"\"\n    Calculate comprehensive volatility statistics for a portfolio.\n\n    Args:\n        portfolio: Portfolio object containing transactions and settings.\n        target_currency: The currency to convert all values into.\n        start_date: The start date for the calculation (inclusive).\n                    If None, uses the earliest transaction date.\n        end_date: The end date for the calculation (inclusive).\n                  If None, uses the latest transaction date.\n        periods_in_year: Trading periods in a year (365 for daily).\n\n    Returns:\n        Dictionary containing:\n        - daily_volatility: Daily standard deviation of returns\n        - annual_volatility: Annualized standard deviation\n        - daily_upside_volatility: Daily std of positive returns (or None)\n        - annual_upside_volatility: Annualized std of positive returns (or None)\n        - daily_downside_volatility: Daily std of negative returns (or None)\n        - annual_downside_volatility: Annualized std of negative returns (or None)\n        - volatility_ratio: Downside/upside volatility ratio (or None)\n    \"\"\"\n    # Get daily portfolio values\n    portfolio_values = calculate_portfolio_value_by_day(\n        portfolio,\n        target_currency,\n        start_date,\n        end_date\n    )\n\n    if len(portfolio_values) &lt; 2:\n        return {\n            \"daily_volatility\": None,\n            \"annual_volatility\": None,\n            \"daily_upside_volatility\": None,\n            \"annual_upside_volatility\": None,\n            \"daily_downside_volatility\": None,\n            \"annual_downside_volatility\": None,\n            \"volatility_ratio\": None,\n        }\n\n    daily_returns = calculate_daily_returns(portfolio_values)\n    returns_list = [daily_returns[d] for d in sorted(daily_returns.keys())]\n\n    # Calculate overall volatility\n    try:\n        daily_vol, annual_vol = calculate_volatility(returns_list, periods_in_year)\n    except ValueError:\n        daily_vol, annual_vol = None, None\n\n    # Calculate upside volatility\n    try:\n        daily_up_vol, annual_up_vol = calculate_upside_volatility(returns_list, periods_in_year)\n    except ValueError:\n        daily_up_vol, annual_up_vol = None, None\n\n    # Calculate downside volatility\n    try:\n        daily_down_vol, annual_down_vol = calculate_downside_volatility(returns_list, periods_in_year)\n    except ValueError:\n        daily_down_vol, annual_down_vol = None, None\n\n    # Calculate volatility ratio\n    vol_ratio = calculate_volatility_ratio(returns_list)\n\n    return {\n        \"daily_volatility\": daily_vol,\n        \"annual_volatility\": annual_vol,\n        \"daily_upside_volatility\": daily_up_vol,\n        \"annual_upside_volatility\": annual_up_vol,\n        \"daily_downside_volatility\": daily_down_vol,\n        \"annual_downside_volatility\": annual_down_vol,\n        \"volatility_ratio\": vol_ratio,\n    }\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_win_rate_all_positions","title":"<code>calculate_win_rate_all_positions(portfolio, as_of=None)</code>","text":"<p>Calculate win rate based on all positions (open and closed).</p> <p>For closed positions, uses realized gain/loss. For open positions, uses unrealized gain/loss based on current market value.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions.</p> required <code>as_of</code> <code>datetime | None</code> <p>The datetime to evaluate positions at.    If None, uses the latest transaction date.</p> <code>None</code> <p>Returns:</p> Type Description <code>WinRateResult</code> <p>WinRateResult containing win rate statistics for all positions.</p> Source code in <code>src/athena/metrics/win_rate.py</code> <pre><code>def calculate_win_rate_all_positions(\n    portfolio: Portfolio,\n    as_of: datetime | None = None\n) -&gt; WinRateResult:\n    \"\"\"\n    Calculate win rate based on all positions (open and closed).\n\n    For closed positions, uses realized gain/loss.\n    For open positions, uses unrealized gain/loss based on current market value.\n\n    Args:\n        portfolio: Portfolio object containing transactions.\n        as_of: The datetime to evaluate positions at.\n               If None, uses the latest transaction date.\n\n    Returns:\n        WinRateResult containing win rate statistics for all positions.\n    \"\"\"\n    if as_of is None:\n        if not portfolio.transactions:\n            return WinRateResult(\n                win_rate=0.0,\n                total_positions=0,\n                winning_positions=0,\n                losing_positions=0,\n                breakeven_positions=0,\n                total_gain_loss=Decimal(\"0\"),\n                average_win=None,\n                average_loss=None,\n                win_loss_ratio=None\n            )\n        sorted_txns = sorted(portfolio.transactions, key=lambda t: t.transaction_datetime)\n        as_of = sorted_txns[-1].transaction_datetime\n\n    # Get closed positions\n    closed_positions = get_closed_positions(portfolio, as_of)\n\n    # Get open positions\n    open_positions = get_positions(as_of, portfolio)\n\n    # Combine gains/losses\n    all_gains_losses: list[Decimal] = []\n\n    # Add closed position gains/losses\n    for pos in closed_positions:\n        all_gains_losses.append(pos.realized_gain_loss)\n\n    # Add open position gains/losses (unrealized)\n    for pos in open_positions:\n        if pos.gain_loss is not None:\n            all_gains_losses.append(pos.gain_loss)\n\n    if not all_gains_losses:\n        return WinRateResult(\n            win_rate=0.0,\n            total_positions=0,\n            winning_positions=0,\n            losing_positions=0,\n            breakeven_positions=0,\n            total_gain_loss=Decimal(\"0\"),\n            average_win=None,\n            average_loss=None,\n            win_loss_ratio=None\n        )\n\n    winning = [gl for gl in all_gains_losses if gl &gt; 0]\n    losing = [gl for gl in all_gains_losses if gl &lt; 0]\n    breakeven = [gl for gl in all_gains_losses if gl == 0]\n\n    total_positions = len(all_gains_losses)\n    winning_positions = len(winning)\n    losing_positions = len(losing)\n    breakeven_positions = len(breakeven)\n\n    win_rate = winning_positions / total_positions if total_positions &gt; 0 else 0.0\n\n    total_gain_loss = sum(all_gains_losses)\n\n    average_win = (\n        sum(winning) / winning_positions\n        if winning_positions &gt; 0 else None\n    )\n\n    average_loss = (\n        sum(losing) / losing_positions\n        if losing_positions &gt; 0 else None\n    )\n\n    win_loss_ratio = (\n        float(abs(average_win / average_loss))\n        if average_win is not None and average_loss is not None and average_loss != 0\n        else None\n    )\n\n    return WinRateResult(\n        win_rate=win_rate,\n        total_positions=total_positions,\n        winning_positions=winning_positions,\n        losing_positions=losing_positions,\n        breakeven_positions=breakeven_positions,\n        total_gain_loss=total_gain_loss,\n        average_win=average_win,\n        average_loss=average_loss,\n        win_loss_ratio=win_loss_ratio\n    )\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_win_rate_by_symbol","title":"<code>calculate_win_rate_by_symbol(portfolio, as_of=None, include_open=False)</code>","text":"<p>Calculate win rate statistics grouped by symbol.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions.</p> required <code>as_of</code> <code>datetime | None</code> <p>Only consider transactions up to this datetime.    If None, considers all transactions.</p> <code>None</code> <code>include_open</code> <code>bool</code> <p>If True, includes unrealized gains from open positions.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[str, WinRateResult]</code> <p>Dictionary mapping symbol to WinRateResult.</p> Source code in <code>src/athena/metrics/win_rate.py</code> <pre><code>def calculate_win_rate_by_symbol(\n    portfolio: Portfolio,\n    as_of: datetime | None = None,\n    include_open: bool = False\n) -&gt; dict[str, WinRateResult]:\n    \"\"\"\n    Calculate win rate statistics grouped by symbol.\n\n    Args:\n        portfolio: Portfolio object containing transactions.\n        as_of: Only consider transactions up to this datetime.\n               If None, considers all transactions.\n        include_open: If True, includes unrealized gains from open positions.\n\n    Returns:\n        Dictionary mapping symbol to WinRateResult.\n    \"\"\"\n    if as_of is None and portfolio.transactions:\n        sorted_txns = sorted(portfolio.transactions, key=lambda t: t.transaction_datetime)\n        as_of = sorted_txns[-1].transaction_datetime\n\n    closed_positions = get_closed_positions(portfolio, as_of)\n\n    # Group closed positions by symbol\n    by_symbol: dict[str, list[Decimal]] = {}\n    for pos in closed_positions:\n        if pos.symbol not in by_symbol:\n            by_symbol[pos.symbol] = []\n        by_symbol[pos.symbol].append(pos.realized_gain_loss)\n\n    # Add open positions if requested\n    if include_open and as_of is not None:\n        open_positions = get_positions(as_of, portfolio)\n        for pos in open_positions:\n            if pos.gain_loss is not None:\n                if pos.symbol not in by_symbol:\n                    by_symbol[pos.symbol] = []\n                by_symbol[pos.symbol].append(pos.gain_loss)\n\n    # Calculate win rate for each symbol\n    results: dict[str, WinRateResult] = {}\n    for symbol, gains_losses in by_symbol.items():\n        if not gains_losses:\n            continue\n\n        winning = [gl for gl in gains_losses if gl &gt; 0]\n        losing = [gl for gl in gains_losses if gl &lt; 0]\n        breakeven = [gl for gl in gains_losses if gl == 0]\n\n        total_positions = len(gains_losses)\n        winning_positions = len(winning)\n        losing_positions = len(losing)\n        breakeven_positions = len(breakeven)\n\n        win_rate = winning_positions / total_positions if total_positions &gt; 0 else 0.0\n\n        total_gain_loss = sum(gains_losses)\n\n        average_win = (\n            sum(winning) / winning_positions\n            if winning_positions &gt; 0 else None\n        )\n\n        average_loss = (\n            sum(losing) / losing_positions\n            if losing_positions &gt; 0 else None\n        )\n\n        win_loss_ratio = (\n            float(abs(average_win / average_loss))\n            if average_win is not None and average_loss is not None and average_loss != 0\n            else None\n        )\n\n        results[symbol] = WinRateResult(\n            win_rate=win_rate,\n            total_positions=total_positions,\n            winning_positions=winning_positions,\n            losing_positions=losing_positions,\n            breakeven_positions=breakeven_positions,\n            total_gain_loss=total_gain_loss,\n            average_win=average_win,\n            average_loss=average_loss,\n            win_loss_ratio=win_loss_ratio\n        )\n\n    return results\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.calculate_win_rate_closed","title":"<code>calculate_win_rate_closed(portfolio, as_of=None)</code>","text":"<p>Calculate win rate based on closed positions only.</p> <p>A winning position is one where the sell price is higher than the buy price. Uses FIFO matching to pair buys with sells.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions.</p> required <code>as_of</code> <code>datetime | None</code> <p>Only consider transactions up to this datetime.    If None, considers all transactions.</p> <code>None</code> <p>Returns:</p> Type Description <code>WinRateResult</code> <p>WinRateResult containing win rate statistics for closed positions.</p> Source code in <code>src/athena/metrics/win_rate.py</code> <pre><code>def calculate_win_rate_closed(\n    portfolio: Portfolio,\n    as_of: datetime | None = None\n) -&gt; WinRateResult:\n    \"\"\"\n    Calculate win rate based on closed positions only.\n\n    A winning position is one where the sell price is higher than the buy price.\n    Uses FIFO matching to pair buys with sells.\n\n    Args:\n        portfolio: Portfolio object containing transactions.\n        as_of: Only consider transactions up to this datetime.\n               If None, considers all transactions.\n\n    Returns:\n        WinRateResult containing win rate statistics for closed positions.\n    \"\"\"\n    closed_positions = get_closed_positions(portfolio, as_of)\n\n    if not closed_positions:\n        return WinRateResult(\n            win_rate=0.0,\n            total_positions=0,\n            winning_positions=0,\n            losing_positions=0,\n            breakeven_positions=0,\n            total_gain_loss=Decimal(\"0\"),\n            average_win=None,\n            average_loss=None,\n            win_loss_ratio=None\n        )\n\n    winning = [p for p in closed_positions if p.realized_gain_loss &gt; 0]\n    losing = [p for p in closed_positions if p.realized_gain_loss &lt; 0]\n    breakeven = [p for p in closed_positions if p.realized_gain_loss == 0]\n\n    total_positions = len(closed_positions)\n    winning_positions = len(winning)\n    losing_positions = len(losing)\n    breakeven_positions = len(breakeven)\n\n    win_rate = winning_positions / total_positions if total_positions &gt; 0 else 0.0\n\n    total_gain_loss = sum(p.realized_gain_loss for p in closed_positions)\n\n    average_win = (\n        sum(p.realized_gain_loss for p in winning) / winning_positions\n        if winning_positions &gt; 0 else None\n    )\n\n    average_loss = (\n        sum(p.realized_gain_loss for p in losing) / losing_positions\n        if losing_positions &gt; 0 else None\n    )\n\n    win_loss_ratio = (\n        float(abs(average_win / average_loss))\n        if average_win is not None and average_loss is not None and average_loss != 0\n        else None\n    )\n\n    return WinRateResult(\n        win_rate=win_rate,\n        total_positions=total_positions,\n        winning_positions=winning_positions,\n        losing_positions=losing_positions,\n        breakeven_positions=breakeven_positions,\n        total_gain_loss=total_gain_loss,\n        average_win=average_win,\n        average_loss=average_loss,\n        win_loss_ratio=win_loss_ratio\n    )\n</code></pre>"},{"location":"reference/metrics/#athena.metrics.get_closed_positions","title":"<code>get_closed_positions(portfolio, as_of=None)</code>","text":"<p>Get all closed positions from a portfolio.</p> <p>A closed position is created when shares are sold. This uses FIFO (First In, First Out) matching to pair buys with sells.</p> <p>Parameters:</p> Name Type Description Default <code>portfolio</code> <code>Portfolio</code> <p>Portfolio object containing transactions.</p> required <code>as_of</code> <code>datetime | None</code> <p>Only consider transactions up to this datetime.    If None, considers all transactions.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[ClosedPosition]</code> <p>List of ClosedPosition objects representing realized trades.</p> Source code in <code>src/athena/metrics/win_rate.py</code> <pre><code>def get_closed_positions(\n    portfolio: Portfolio,\n    as_of: datetime | None = None\n) -&gt; list[ClosedPosition]:\n    \"\"\"\n    Get all closed positions from a portfolio.\n\n    A closed position is created when shares are sold. This uses FIFO\n    (First In, First Out) matching to pair buys with sells.\n\n    Args:\n        portfolio: Portfolio object containing transactions.\n        as_of: Only consider transactions up to this datetime.\n               If None, considers all transactions.\n\n    Returns:\n        List of ClosedPosition objects representing realized trades.\n    \"\"\"\n    # Track open lots for each symbol using FIFO\n    # Each lot is (quantity, price, date, currency)\n    open_lots: dict[str, list[tuple[Decimal, Decimal, datetime, Currency]]] = {}\n    closed_positions: list[ClosedPosition] = []\n\n    sorted_transactions = sorted(\n        portfolio.transactions,\n        key=lambda t: t.transaction_datetime\n    )\n\n    for txn in sorted_transactions:\n        if as_of is not None and txn.transaction_datetime &gt; as_of:\n            break\n\n        symbol = txn.symbol\n        quantity = txn.quantity\n        price = Decimal(str(txn.price))\n        currency = txn.currency\n\n        if txn.transaction_type == TransactionType.BUY:\n            if symbol not in open_lots:\n                open_lots[symbol] = []\n            open_lots[symbol].append((quantity, price, txn.transaction_datetime, currency))\n\n        elif txn.transaction_type == TransactionType.SELL:\n            if symbol not in open_lots or not open_lots[symbol]:\n                continue\n\n            remaining_to_sell = quantity\n            sell_price = price\n            sell_date = txn.transaction_datetime\n\n            while remaining_to_sell &gt; 0 and open_lots[symbol]:\n                lot = open_lots[symbol][0]\n                lot_qty, lot_price, lot_date, lot_currency = lot\n\n                if lot_qty &lt;= remaining_to_sell:\n                    # Close entire lot\n                    open_lots[symbol].pop(0)\n                    closed_qty = lot_qty\n                    remaining_to_sell -= lot_qty\n                else:\n                    # Partially close lot\n                    open_lots[symbol][0] = (\n                        lot_qty - remaining_to_sell,\n                        lot_price,\n                        lot_date,\n                        lot_currency\n                    )\n                    closed_qty = remaining_to_sell\n                    remaining_to_sell = Decimal(\"0\")\n\n                # Calculate realized gain/loss\n                buy_value = closed_qty * lot_price\n                sell_value = closed_qty * sell_price\n                realized_gain_loss = sell_value - buy_value\n\n                if buy_value != 0:\n                    realized_gain_loss_percent = (realized_gain_loss / buy_value) * 100\n                else:\n                    realized_gain_loss_percent = Decimal(\"0\")\n\n                closed_positions.append(ClosedPosition(\n                    symbol=symbol,\n                    quantity=closed_qty,\n                    buy_price=lot_price,\n                    sell_price=sell_price,\n                    buy_date=lot_date,\n                    sell_date=sell_date,\n                    currency=lot_currency,\n                    realized_gain_loss=realized_gain_loss,\n                    realized_gain_loss_percent=realized_gain_loss_percent\n                ))\n\n    return closed_positions\n</code></pre>"},{"location":"reference/pricingdata/","title":"pricingdata","text":""},{"location":"reference/pricingdata/#athena.pricingdata","title":"<code>athena.pricingdata</code>","text":""},{"location":"reference/pricingdata/#athena.pricingdata.PricePoint","title":"<code>PricePoint</code>","text":"<p>A single price observation for a financial instrument.</p> Source code in <code>src/athena/pricingdata.py</code> <pre><code>class PricePoint:\n    \"\"\"A single price observation for a financial instrument.\"\"\"\n\n    def __init__(self, symbol: str, price_datetime: datetime, price: Decimal, base_currency:Currency = Currency.USD):\n        \"\"\"Initialize a PricePoint.\n\n        Args:\n            symbol: Ticker or contract symbol (e.g., \"AAPL\", \"NGH26\").\n            price_datetime: The datetime the price was observed.\n            price: The observed price as a Decimal.\n            base_currency: Currency the price is denominated in.\n        \"\"\"\n        self.symbol: str = symbol\n        self.price_datetime: datetime = price_datetime\n        self.price: Decimal = price\n        self.base_currency:Currency = base_currency\n</code></pre>"},{"location":"reference/pricingdata/#athena.pricingdata.PricePoint.__init__","title":"<code>__init__(symbol, price_datetime, price, base_currency=Currency.USD)</code>","text":"<p>Initialize a PricePoint.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Ticker or contract symbol (e.g., \"AAPL\", \"NGH26\").</p> required <code>price_datetime</code> <code>datetime</code> <p>The datetime the price was observed.</p> required <code>price</code> <code>Decimal</code> <p>The observed price as a Decimal.</p> required <code>base_currency</code> <code>Currency</code> <p>Currency the price is denominated in.</p> <code>USD</code> Source code in <code>src/athena/pricingdata.py</code> <pre><code>def __init__(self, symbol: str, price_datetime: datetime, price: Decimal, base_currency:Currency = Currency.USD):\n    \"\"\"Initialize a PricePoint.\n\n    Args:\n        symbol: Ticker or contract symbol (e.g., \"AAPL\", \"NGH26\").\n        price_datetime: The datetime the price was observed.\n        price: The observed price as a Decimal.\n        base_currency: Currency the price is denominated in.\n    \"\"\"\n    self.symbol: str = symbol\n    self.price_datetime: datetime = price_datetime\n    self.price: Decimal = price\n    self.base_currency:Currency = base_currency\n</code></pre>"},{"location":"reference/pricingdata/#athena.pricingdata.PricingDataManager","title":"<code>PricingDataManager</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for all pricing data providers.</p> Source code in <code>src/athena/pricingdata.py</code> <pre><code>class PricingDataManager(ABC):\n    \"\"\"Abstract base class for all pricing data providers.\"\"\"\n\n    @abstractmethod\n    def get_price_point(self, symbol: str, price_datetime: datetime) -&gt; PricePoint:\n        raise NotImplementedError(\"This method should be overridden by subclasses.\")\n</code></pre>"},{"location":"reference/pricingdata/#athena.pricingdata.FixedPricingDataManager","title":"<code>FixedPricingDataManager</code>","text":"<p>               Bases: <code>PricingDataManager</code></p> <p>Pricing manager that returns a fixed price for any symbol/datetime.</p> Source code in <code>src/athena/pricingdata.py</code> <pre><code>class FixedPricingDataManager(PricingDataManager):\n    \"\"\"Pricing manager that returns a fixed price for any symbol/datetime.\"\"\"\n\n    def __init__(self, price_for_everything:Decimal = Decimal(\"1.0\")):\n        \"\"\"Initialize with a fixed price.\n\n        Args:\n            price_for_everything: The constant price returned for every query.\n        \"\"\"\n        self.price = price_for_everything\n\n    def get_price_point(self, symbol: str, price_datetime: datetime) -&gt; PricePoint:\n        \"\"\"Return a PricePoint with the fixed price.\n\n        Args:\n            symbol: The ticker symbol (ignored; always returns the fixed price).\n            price_datetime: The requested datetime (passed through to the result).\n\n        Returns:\n            PricePoint with the fixed price in USD.\n        \"\"\"\n        price_point = PricePoint(\n            symbol=symbol,\n            price_datetime=price_datetime,\n            price=self.price,\n            base_currency=Currency.USD\n        )\n\n        return price_point\n</code></pre>"},{"location":"reference/pricingdata/#athena.pricingdata.FixedPricingDataManager.__init__","title":"<code>__init__(price_for_everything=Decimal('1.0'))</code>","text":"<p>Initialize with a fixed price.</p> <p>Parameters:</p> Name Type Description Default <code>price_for_everything</code> <code>Decimal</code> <p>The constant price returned for every query.</p> <code>Decimal('1.0')</code> Source code in <code>src/athena/pricingdata.py</code> <pre><code>def __init__(self, price_for_everything:Decimal = Decimal(\"1.0\")):\n    \"\"\"Initialize with a fixed price.\n\n    Args:\n        price_for_everything: The constant price returned for every query.\n    \"\"\"\n    self.price = price_for_everything\n</code></pre>"},{"location":"reference/pricingdata/#athena.pricingdata.FixedPricingDataManager.get_price_point","title":"<code>get_price_point(symbol, price_datetime)</code>","text":"<p>Return a PricePoint with the fixed price.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The ticker symbol (ignored; always returns the fixed price).</p> required <code>price_datetime</code> <code>datetime</code> <p>The requested datetime (passed through to the result).</p> required <p>Returns:</p> Type Description <code>PricePoint</code> <p>PricePoint with the fixed price in USD.</p> Source code in <code>src/athena/pricingdata.py</code> <pre><code>def get_price_point(self, symbol: str, price_datetime: datetime) -&gt; PricePoint:\n    \"\"\"Return a PricePoint with the fixed price.\n\n    Args:\n        symbol: The ticker symbol (ignored; always returns the fixed price).\n        price_datetime: The requested datetime (passed through to the result).\n\n    Returns:\n        PricePoint with the fixed price in USD.\n    \"\"\"\n    price_point = PricePoint(\n        symbol=symbol,\n        price_datetime=price_datetime,\n        price=self.price,\n        base_currency=Currency.USD\n    )\n\n    return price_point\n</code></pre>"},{"location":"reference/pricingdata/#athena.pricingdata.YFinancePricingDataManager","title":"<code>YFinancePricingDataManager</code>","text":"<p>               Bases: <code>PricingDataManager</code></p> Source code in <code>src/athena/pricingdata.py</code> <pre><code>class YFinancePricingDataManager(PricingDataManager):\n\n    def __init__(self, force_cache_refresh: bool = False):\n        \"\"\"Initialize the YFinance pricing manager.\n\n        Args:\n            force_cache_refresh: If True, bypass the disk cache and fetch\n                fresh data from Yahoo Finance (once per symbol per session).\n        \"\"\"\n        self.force_cache_refresh = force_cache_refresh\n\n    def get_price_point(self, symbol: str, price_datetime: datetime) -&gt; PricePoint:\n        \"\"\"Get price for a symbol on a specific date.\n\n        If no data is available for the requested date (weekend, holiday),\n        looks back up to 7 days to find the most recent trading day.\n\n        For today's date during market hours, uses the current market price\n        since the daily close isn't available yet.\n        \"\"\"\n        target_date = price_datetime.date()\n        today = date.today()\n\n        # If requesting today's price, try to get the current/live market price first\n        # since the daily close isn't available until market closes\n        if target_date == today:\n            try:\n                ticker = yf.Ticker(symbol)\n                # Use fast_info['lastPrice'] which provides the most recent price\n                # including pre-market and after-hours trading, unlike regularMarketPrice\n                # which only returns the last regular session close\n                fast_info = ticker.fast_info\n                current_price = fast_info.get('lastPrice')\n                if current_price is not None:\n                    price = Decimal(str(current_price)).quantize(Decimal(\"0.01\"))\n                    return PricePoint(\n                        symbol=symbol,\n                        price_datetime=datetime.now(),\n                        price=price,\n                        base_currency=Currency.USD\n                    )\n            except Exception:\n                pass  # Fall through to historical data lookup\n\n        # Fetch data - request a window to handle weekends/holidays\n        # We ask for 10 days before to ensure we have data even if target is a Monday after a long weekend\n        min_date = target_date - timedelta(days=10)\n        max_date = target_date\n\n        df = fetch_yfinance_data(symbol, min_date, max_date, self.force_cache_refresh)\n\n        if df.empty:\n            raise ValueError(f\"No price data available for {symbol}\")\n\n        # Look for the target date or the most recent date before it\n        for days_back in range(8):\n            lookup_date = target_date - timedelta(days=days_back)\n            matching_rows = df[df['Date'] == lookup_date]\n            if not matching_rows.empty:\n                row = matching_rows.iloc[0]\n                price = Decimal(str(row['Close'])).quantize(Decimal(\"0.01\"))\n                return PricePoint(\n                    symbol=symbol,\n                    price_datetime=datetime.combine(lookup_date, datetime.min.time()),\n                    price=price,\n                    base_currency=Currency.USD\n                )\n\n        raise ValueError(\n            f\"No price data available for {symbol} on {target_date} or the previous 7 days.\"\n        )\n</code></pre>"},{"location":"reference/pricingdata/#athena.pricingdata.YFinancePricingDataManager.__init__","title":"<code>__init__(force_cache_refresh=False)</code>","text":"<p>Initialize the YFinance pricing manager.</p> <p>Parameters:</p> Name Type Description Default <code>force_cache_refresh</code> <code>bool</code> <p>If True, bypass the disk cache and fetch fresh data from Yahoo Finance (once per symbol per session).</p> <code>False</code> Source code in <code>src/athena/pricingdata.py</code> <pre><code>def __init__(self, force_cache_refresh: bool = False):\n    \"\"\"Initialize the YFinance pricing manager.\n\n    Args:\n        force_cache_refresh: If True, bypass the disk cache and fetch\n            fresh data from Yahoo Finance (once per symbol per session).\n    \"\"\"\n    self.force_cache_refresh = force_cache_refresh\n</code></pre>"},{"location":"reference/pricingdata/#athena.pricingdata.YFinancePricingDataManager.get_price_point","title":"<code>get_price_point(symbol, price_datetime)</code>","text":"<p>Get price for a symbol on a specific date.</p> <p>If no data is available for the requested date (weekend, holiday), looks back up to 7 days to find the most recent trading day.</p> <p>For today's date during market hours, uses the current market price since the daily close isn't available yet.</p> Source code in <code>src/athena/pricingdata.py</code> <pre><code>def get_price_point(self, symbol: str, price_datetime: datetime) -&gt; PricePoint:\n    \"\"\"Get price for a symbol on a specific date.\n\n    If no data is available for the requested date (weekend, holiday),\n    looks back up to 7 days to find the most recent trading day.\n\n    For today's date during market hours, uses the current market price\n    since the daily close isn't available yet.\n    \"\"\"\n    target_date = price_datetime.date()\n    today = date.today()\n\n    # If requesting today's price, try to get the current/live market price first\n    # since the daily close isn't available until market closes\n    if target_date == today:\n        try:\n            ticker = yf.Ticker(symbol)\n            # Use fast_info['lastPrice'] which provides the most recent price\n            # including pre-market and after-hours trading, unlike regularMarketPrice\n            # which only returns the last regular session close\n            fast_info = ticker.fast_info\n            current_price = fast_info.get('lastPrice')\n            if current_price is not None:\n                price = Decimal(str(current_price)).quantize(Decimal(\"0.01\"))\n                return PricePoint(\n                    symbol=symbol,\n                    price_datetime=datetime.now(),\n                    price=price,\n                    base_currency=Currency.USD\n                )\n        except Exception:\n            pass  # Fall through to historical data lookup\n\n    # Fetch data - request a window to handle weekends/holidays\n    # We ask for 10 days before to ensure we have data even if target is a Monday after a long weekend\n    min_date = target_date - timedelta(days=10)\n    max_date = target_date\n\n    df = fetch_yfinance_data(symbol, min_date, max_date, self.force_cache_refresh)\n\n    if df.empty:\n        raise ValueError(f\"No price data available for {symbol}\")\n\n    # Look for the target date or the most recent date before it\n    for days_back in range(8):\n        lookup_date = target_date - timedelta(days=days_back)\n        matching_rows = df[df['Date'] == lookup_date]\n        if not matching_rows.empty:\n            row = matching_rows.iloc[0]\n            price = Decimal(str(row['Close'])).quantize(Decimal(\"0.01\"))\n            return PricePoint(\n                symbol=symbol,\n                price_datetime=datetime.combine(lookup_date, datetime.min.time()),\n                price=price,\n                base_currency=Currency.USD\n            )\n\n    raise ValueError(\n        f\"No price data available for {symbol} on {target_date} or the previous 7 days.\"\n    )\n</code></pre>"},{"location":"reference/pricingdata/#athena.pricingdata.MassivePricingDataManager","title":"<code>MassivePricingDataManager</code>","text":"<p>               Bases: <code>PricingDataManager</code></p> <p>Pricing data manager using the Massive API.</p> Source code in <code>src/athena/pricingdata.py</code> <pre><code>class MassivePricingDataManager(PricingDataManager):\n    \"\"\"Pricing data manager using the Massive API.\"\"\"\n\n    _PREFETCH_DAYS = 730\n\n    def __init__(self, api_key: str, force_cache_refresh: bool = False):\n        \"\"\"Initialize the Massive client.\n\n        Args:\n            api_key: Massive API key.\n            force_cache_refresh: If True, ignore disk cache and fetch fresh\n                from API (but still use in-memory cache within the session).\n        \"\"\"\n        self._client = RESTClient(api_key)\n        self._force_cache_refresh = force_cache_refresh\n        # In-memory cache: (symbol, date) \u2192 Decimal close price.\n        self._price_cache: dict[tuple[str, date], Decimal] = {}\n        # Track which symbols have been loaded from disk this session.\n        self._disk_loaded: set[str] = set()\n\n    @staticmethod\n    def _get_cache_path(symbol: str) -&gt; Path:\n        \"\"\"Get the disk-cache file path for a symbol.\n\n        Args:\n            symbol: The ticker symbol.\n\n        Returns:\n            Path to the CSV cache file under ``.cache/massive_prices/``.\n        \"\"\"\n        return Path.cwd() / \".cache\" / \"massive_prices\" / f\"{symbol}.csv\"\n\n    def _load_disk_cache(self, symbol: str) -&gt; None:\n        \"\"\"Load cached prices for a symbol from disk into memory.\n\n        Args:\n            symbol: The ticker symbol to load from disk cache.\n        \"\"\"\n        if symbol in self._disk_loaded:\n            return\n        self._disk_loaded.add(symbol)\n\n        cache_path = self._get_cache_path(symbol)\n        if not cache_path.exists():\n            return\n        try:\n            df = pd.read_csv(cache_path)\n            count = 0\n            for _, row in df.iterrows():\n                trade_date = date.fromisoformat(str(row[\"Date\"]))\n                price = Decimal(str(row[\"Close\"])).quantize(Decimal(\"0.01\"))\n                self._price_cache[(symbol, trade_date)] = price\n                count += 1\n            if verbose:\n                print(f\"  Massive: loaded {count} days from disk cache for {symbol}\", flush=True)\n        except Exception:\n            pass  # Corrupted cache, will refetch from API\n\n    def _save_disk_cache(self, symbol: str) -&gt; None:\n        \"\"\"Persist all cached prices for a symbol to disk.\n\n        Args:\n            symbol: The ticker symbol whose in-memory prices are written to CSV.\n        \"\"\"\n        cache_path = self._get_cache_path(symbol)\n        cache_path.parent.mkdir(parents=True, exist_ok=True)\n\n        rows = []\n        for (sym, trade_date), price in self._price_cache.items():\n            if sym == symbol:\n                rows.append({\"Date\": trade_date.isoformat(), \"Close\": str(price)})\n\n        if rows:\n            df = pd.DataFrame(rows).sort_values(\"Date\").drop_duplicates(subset=[\"Date\"], keep=\"last\")\n            df.to_csv(cache_path, index=False)\n\n    def _populate_cache(self, symbol: str, min_date: date, max_date: date) -&gt; None:\n        \"\"\"Fetch daily aggregates from Massive and cache all returned dates.\n\n        Args:\n            symbol: The ticker symbol to fetch.\n            min_date: Start of the date range (inclusive).\n            max_date: End of the date range (inclusive).\n        \"\"\"\n        try:\n            aggs = list(self._client.list_aggs(\n                ticker=symbol,\n                multiplier=1,\n                timespan=\"day\",\n                from_=min_date.isoformat(),\n                to=max_date.isoformat(),\n                limit=5000,\n            ))\n        except Exception as e:\n            raise ValueError(f\"Error fetching price data for {symbol}: {e}\") from e\n\n        for agg in aggs:\n            agg_date = datetime.fromtimestamp(agg.timestamp / 1000).date()  # type: ignore[union-attr]\n            self._price_cache[(symbol, agg_date)] = Decimal(str(agg.close)).quantize(Decimal(\"0.01\"))  # type: ignore[union-attr]\n\n        if verbose:\n            print(f\"  Massive: fetched {len(aggs)} days for {symbol}\", flush=True)\n\n        self._save_disk_cache(symbol)\n\n    def get_price_point(self, symbol: str, price_datetime: datetime) -&gt; PricePoint:\n        \"\"\"Get price for a symbol on a specific date.\n\n        Loads from disk cache on first access (unless --no-cache). Falls back\n        to the API when data is missing. Recent dates (today/yesterday) always\n        trigger a fresh API fetch.\n        \"\"\"\n        target_date = price_datetime.date()\n        today = date.today()\n        is_recent = (today - target_date).days &lt;= 1\n\n        # Load from disk cache on first access (unless --no-cache).\n        if not self._force_cache_refresh:\n            self._load_disk_cache(symbol)\n\n        # For recent dates, always fetch fresh data first.\n        if is_recent:\n            fresh_start = target_date - timedelta(days=10)\n            self._populate_cache(symbol, fresh_start, today)\n\n        # Check cache (including nearby dates for weekends/holidays).\n        for days_back in range(8):\n            lookup_date = target_date - timedelta(days=days_back)\n            cached = self._price_cache.get((symbol, lookup_date))\n            if cached is not None:\n                return PricePoint(\n                    symbol=symbol,\n                    price_datetime=datetime.combine(lookup_date, datetime.min.time()),\n                    price=cached,\n                    base_currency=Currency.USD,\n                )\n\n        # Full cache miss \u2014 fetch a broad range.\n        min_date = target_date - timedelta(days=self._PREFETCH_DAYS)\n        self._populate_cache(symbol, min_date, target_date)\n\n        # Retry from cache after fetch.\n        for days_back in range(8):\n            lookup_date = target_date - timedelta(days=days_back)\n            cached = self._price_cache.get((symbol, lookup_date))\n            if cached is not None:\n                return PricePoint(\n                    symbol=symbol,\n                    price_datetime=datetime.combine(lookup_date, datetime.min.time()),\n                    price=cached,\n                    base_currency=Currency.USD,\n                )\n\n        raise ValueError(\n            f\"No price data available for {symbol} on {target_date} or the previous 7 days.\"\n        )\n</code></pre>"},{"location":"reference/pricingdata/#athena.pricingdata.MassivePricingDataManager.__init__","title":"<code>__init__(api_key, force_cache_refresh=False)</code>","text":"<p>Initialize the Massive client.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str</code> <p>Massive API key.</p> required <code>force_cache_refresh</code> <code>bool</code> <p>If True, ignore disk cache and fetch fresh from API (but still use in-memory cache within the session).</p> <code>False</code> Source code in <code>src/athena/pricingdata.py</code> <pre><code>def __init__(self, api_key: str, force_cache_refresh: bool = False):\n    \"\"\"Initialize the Massive client.\n\n    Args:\n        api_key: Massive API key.\n        force_cache_refresh: If True, ignore disk cache and fetch fresh\n            from API (but still use in-memory cache within the session).\n    \"\"\"\n    self._client = RESTClient(api_key)\n    self._force_cache_refresh = force_cache_refresh\n    # In-memory cache: (symbol, date) \u2192 Decimal close price.\n    self._price_cache: dict[tuple[str, date], Decimal] = {}\n    # Track which symbols have been loaded from disk this session.\n    self._disk_loaded: set[str] = set()\n</code></pre>"},{"location":"reference/pricingdata/#athena.pricingdata.MassivePricingDataManager.get_price_point","title":"<code>get_price_point(symbol, price_datetime)</code>","text":"<p>Get price for a symbol on a specific date.</p> <p>Loads from disk cache on first access (unless --no-cache). Falls back to the API when data is missing. Recent dates (today/yesterday) always trigger a fresh API fetch.</p> Source code in <code>src/athena/pricingdata.py</code> <pre><code>def get_price_point(self, symbol: str, price_datetime: datetime) -&gt; PricePoint:\n    \"\"\"Get price for a symbol on a specific date.\n\n    Loads from disk cache on first access (unless --no-cache). Falls back\n    to the API when data is missing. Recent dates (today/yesterday) always\n    trigger a fresh API fetch.\n    \"\"\"\n    target_date = price_datetime.date()\n    today = date.today()\n    is_recent = (today - target_date).days &lt;= 1\n\n    # Load from disk cache on first access (unless --no-cache).\n    if not self._force_cache_refresh:\n        self._load_disk_cache(symbol)\n\n    # For recent dates, always fetch fresh data first.\n    if is_recent:\n        fresh_start = target_date - timedelta(days=10)\n        self._populate_cache(symbol, fresh_start, today)\n\n    # Check cache (including nearby dates for weekends/holidays).\n    for days_back in range(8):\n        lookup_date = target_date - timedelta(days=days_back)\n        cached = self._price_cache.get((symbol, lookup_date))\n        if cached is not None:\n            return PricePoint(\n                symbol=symbol,\n                price_datetime=datetime.combine(lookup_date, datetime.min.time()),\n                price=cached,\n                base_currency=Currency.USD,\n            )\n\n    # Full cache miss \u2014 fetch a broad range.\n    min_date = target_date - timedelta(days=self._PREFETCH_DAYS)\n    self._populate_cache(symbol, min_date, target_date)\n\n    # Retry from cache after fetch.\n    for days_back in range(8):\n        lookup_date = target_date - timedelta(days=days_back)\n        cached = self._price_cache.get((symbol, lookup_date))\n        if cached is not None:\n            return PricePoint(\n                symbol=symbol,\n                price_datetime=datetime.combine(lookup_date, datetime.min.time()),\n                price=cached,\n                base_currency=Currency.USD,\n            )\n\n    raise ValueError(\n        f\"No price data available for {symbol} on {target_date} or the previous 7 days.\"\n    )\n</code></pre>"},{"location":"reference/pricingdata/#athena.pricingdata.DatabentoPricingDataManager","title":"<code>DatabentoPricingDataManager</code>","text":"<p>               Bases: <code>PricingDataManager</code></p> <p>Pricing data manager using the Databento API for futures and options.</p> Source code in <code>src/athena/pricingdata.py</code> <pre><code>class DatabentoPricingDataManager(PricingDataManager):\n    \"\"\"Pricing data manager using the Databento API for futures and options.\"\"\"\n\n    # Dataset constants\n    DATASET_CME = \"GLBX.MDP3\"  # CME Globex - futures &amp; commodities (includes NYMEX)\n    DATASET_OPRA = \"OPRA.PILLAR\"  # OPRA - US equity options\n\n    # How far back to fetch on the first API call for a symbol (calendar days).\n    _PREFETCH_DAYS = 730\n\n    def __init__(self, api_key: str | None = None, dataset: str = DATASET_CME,\n                 force_cache_refresh: bool = False):\n        \"\"\"Initialize the Databento client.\n\n        Args:\n            api_key: Databento API key. If None, reads from DATABENTO_API_KEY env var.\n            dataset: Databento dataset ID (default: GLBX.MDP3 for CME/NYMEX futures)\n            force_cache_refresh: If True, ignore disk cache and fetch fresh\n                from API (but still use in-memory cache within the session).\n        \"\"\"\n        self._api_key = api_key or os.getenv(\"DATABENTO_API_KEY\")\n        if not self._api_key:\n            raise ValueError(\"Databento API key required. Set DATABENTO_API_KEY env var or pass api_key.\")\n        self._dataset = dataset\n        self._force_cache_refresh = force_cache_refresh\n        # In-memory cache: (symbol, date) \u2192 Decimal close price.\n        self._price_cache: dict[tuple[str, date], Decimal] = {}\n        # Remember which symbol variant resolved for each base symbol so we\n        # skip variants that already failed.\n        self._resolved_variant: dict[str, str] = {}\n        # Track which symbols have been loaded from disk this session.\n        self._disk_loaded: set[str] = set()\n\n    @staticmethod\n    def _get_cache_path(symbol: str) -&gt; Path:\n        \"\"\"Get the disk-cache file path for a symbol.\n\n        Args:\n            symbol: The ticker or contract symbol.\n\n        Returns:\n            Path to the CSV cache file under ``.cache/databento_prices/``.\n        \"\"\"\n        return Path.cwd() / \".cache\" / \"databento_prices\" / f\"{symbol}.csv\"\n\n    def _load_disk_cache(self, symbol: str) -&gt; None:\n        \"\"\"Load cached prices for a symbol from disk into memory.\n\n        Args:\n            symbol: The ticker or contract symbol to load from disk cache.\n        \"\"\"\n        if symbol in self._disk_loaded:\n            return\n        self._disk_loaded.add(symbol)\n\n        cache_path = self._get_cache_path(symbol)\n        if not cache_path.exists():\n            return\n        try:\n            df = pd.read_csv(cache_path)\n            count = 0\n            for _, row in df.iterrows():\n                trade_date = date.fromisoformat(str(row[\"Date\"]))\n                price = Decimal(str(row[\"Close\"])).quantize(Decimal(\"0.0001\"))\n                self._price_cache[(symbol, trade_date)] = price\n                count += 1\n            if verbose:\n                print(f\"  Databento: loaded {count} days from disk cache for {symbol}\", flush=True)\n        except Exception:\n            pass  # Corrupted cache, will refetch from API\n\n    def _save_disk_cache(self, symbol: str) -&gt; None:\n        \"\"\"Persist all cached prices for a symbol to disk.\n\n        Args:\n            symbol: The ticker or contract symbol whose prices are written.\n        \"\"\"\n        cache_path = self._get_cache_path(symbol)\n        cache_path.parent.mkdir(parents=True, exist_ok=True)\n\n        rows = []\n        for (sym, trade_date), price in self._price_cache.items():\n            if sym == symbol:\n                rows.append({\"Date\": trade_date.isoformat(), \"Close\": str(price)})\n\n        if rows:\n            df = pd.DataFrame(rows).sort_values(\"Date\").drop_duplicates(subset=[\"Date\"], keep=\"last\")\n            df.to_csv(cache_path, index=False)\n\n    @staticmethod\n    def _is_opra_symbol(symbol: str) -&gt; bool:\n        \"\"\"Check if symbol is an OPRA options contract.\n\n        Args:\n            symbol: The symbol string to test.\n\n        Returns:\n            True if the symbol matches OSI options format, False otherwise.\n        \"\"\"\n        from .metrics.options import parse_osi_symbol\n        return parse_osi_symbol(symbol) is not None\n\n    def _populate_cache(self, symbol: str, start_dt: datetime, end_dt: datetime) -&gt; None:\n        \"\"\"Fetch price data from Databento and cache close/mid prices.\n\n        Uses ohlcv-1d for futures (GLBX) and cbbo-1m for options (OPRA).\n\n        Args:\n            symbol: The ticker or contract symbol to fetch.\n            start_dt: Start of the datetime range (inclusive).\n            end_dt: End of the datetime range (exclusive).\n        \"\"\"\n        is_opra = self._is_opra_symbol(symbol)\n\n        if is_opra:\n            self._populate_cache_opra(symbol, start_dt, end_dt)\n        else:\n            self._populate_cache_futures(symbol, start_dt, end_dt)\n\n    def _populate_cache_futures(self, symbol: str, start_dt: datetime, end_dt: datetime) -&gt; None:\n        \"\"\"Fetch daily OHLCV bars from GLBX for futures symbols.\n\n        Args:\n            symbol: Futures symbol (e.g., \"NGH26\").\n            start_dt: Start of the datetime range (inclusive).\n            end_dt: End of the datetime range (exclusive).\n        \"\"\"\n        resolved = self._resolved_variant.get(symbol)\n        variants = [resolved] if resolved else [symbol, f\"{symbol}.FUT\", symbol.upper()]\n\n        for sym in variants:\n            try:\n                client = db.Historical(self._api_key)\n                data = client.timeseries.get_range(\n                    dataset=self._dataset,\n                    symbols=sym,\n                    schema=\"ohlcv-1d\",\n                    start=start_dt.isoformat(),\n                    end=end_dt.isoformat(),\n                )\n                df = data.to_df()\n\n                if df.empty:\n                    continue\n\n                self._resolved_variant[symbol] = sym\n\n                df['trade_date'] = pd.to_datetime(df.index).date\n                for _, row in df.iterrows():\n                    trade_date = row['trade_date']\n                    price = Decimal(str(float(row[\"close\"]))).quantize(Decimal(\"0.0001\"))\n                    self._price_cache[(symbol, trade_date)] = price\n\n                if verbose:\n                    print(\n                        f\"  Databento: fetched {len(df)} days for {sym}\",\n                        flush=True,\n                    )\n\n                self._save_disk_cache(symbol)\n                return  # success\n\n            except Exception as e:\n                if verbose:\n                    print(f\"  Databento: ohlcv-1d fetch failed for {sym}: {e}\", flush=True)\n                continue\n\n    def _populate_cache_opra(self, symbol: str, start_dt: datetime, end_dt: datetime) -&gt; None:\n        \"\"\"Fetch cbbo-1m data from OPRA for an individual options contract.\n\n        Makes a single bulk query for the full date range (one API call),\n        then groups by day and takes the last bar as the close mid-price.\n\n        Tries the direct contract symbol first. Falls back to a parent\n        query filtered to the contract if that fails.\n\n        Args:\n            symbol: OPRA options symbol (e.g., \"SBUX  260417P00095000\").\n            start_dt: Start of the datetime range (inclusive).\n            end_dt: End of the datetime range (exclusive).\n        \"\"\"\n        from .metrics.options import parse_osi_symbol\n\n        parsed = parse_osi_symbol(symbol)\n        if parsed is None:\n            return\n\n        # OPRA historical data lags ~1 day. Clamp end to yesterday midnight\n        # UTC to avoid data_end_after_available_end errors.\n        yesterday_end = datetime.combine(\n            date.today() - timedelta(days=1),\n            datetime.min.time(),\n            tzinfo=timezone.utc,\n        )\n        if end_dt &gt; yesterday_end:\n            end_dt = yesterday_end\n        if start_dt &gt;= end_dt:\n            return\n\n        client = db.Historical(self._api_key)\n        df = None\n\n        # Attempt 1: direct contract symbol \u2014 one contract's bars only.\n        # The Databento client emits a misleading &gt;5GB size warning based on\n        # a pre-flight estimate that doesn't account for symbol filtering;\n        # actual data for a single contract is typically &lt;1MB.\n        try:\n            with warnings.catch_warnings():\n                warnings.filterwarnings(\"ignore\", message=\".*size.*streaming.*5 GB.*\")\n                data = client.timeseries.get_range(\n                    dataset=self.DATASET_OPRA,\n                    symbols=symbol,\n                    schema=\"cbbo-1m\",\n                    start=start_dt.isoformat(),\n                    end=end_dt.isoformat(),\n                )\n            df = data.to_df()\n            if df.empty:\n                df = None\n        except Exception:\n            df = None\n\n        # Attempt 2: parent query, filtered to the contract.\n        if df is None:\n            try:\n                parent = f\"{parsed['underlying']}.OPT\"\n                data = client.timeseries.get_range(\n                    dataset=self.DATASET_OPRA,\n                    symbols=parent,\n                    schema=\"cbbo-1m\",\n                    stype_in=\"parent\",\n                    start=start_dt.isoformat(),\n                    end=end_dt.isoformat(),\n                )\n                df = data.to_df()\n                if not df.empty:\n                    df = df.reset_index()\n                    df = df[df[\"symbol\"] == symbol]\n                if df.empty:\n                    df = None\n            except Exception as e:\n                if verbose:\n                    print(f\"  Databento OPRA: cbbo-1m fetch failed for {symbol}: {e}\", flush=True)\n                return\n\n        if df is None:\n            return\n\n        df = df.reset_index(drop=True) if \"ts_event\" in df.columns else df.reset_index()\n        df[\"trade_date\"] = pd.to_datetime(df[\"ts_event\"]).dt.date\n\n        # Last bar of each trading day (closest to market close).\n        last_bars = df.groupby(\"trade_date\").last()\n\n        count = 0\n        for trade_date, row in last_bars.iterrows():\n            bid = float(row[\"bid_px_00\"])\n            ask = float(row[\"ask_px_00\"])\n            if bid &gt; 0 and ask &gt; 0:\n                mid = Decimal(str((bid + ask) / 2)).quantize(Decimal(\"0.0001\"))\n                self._price_cache[(symbol, trade_date)] = mid\n                count += 1\n\n        if count &gt; 0:\n            if verbose:\n                print(f\"  Databento OPRA: fetched {count} days for {symbol}\", flush=True)\n            self._save_disk_cache(symbol)\n\n    def get_price_point(self, symbol: str, price_datetime: datetime) -&gt; PricePoint:\n        \"\"\"Get price for a symbol on a specific date.\n\n        Supports futures (GLBX.MDP3) and OPRA options (OPRA.PILLAR).\n        OPRA symbols are detected automatically via OSI format parsing.\n\n        Loads from disk cache on first access (unless --no-cache). Falls back\n        to the Databento API when data is missing. Recent dates\n        (today/yesterday) use live tbbo quotes since ohlcv-1d bars are only\n        available after the trading day ends.\n\n        Args:\n            symbol: Futures symbol (e.g., \"NGH26\") or OPRA options symbol\n                    (e.g., \"SBUX  260417P00095000\")\n            price_datetime: The datetime to get the price for\n\n        Returns:\n            PricePoint with the daily close price (or live mid-price for today)\n        \"\"\"\n        target_date = price_datetime.date()\n        today = date.today()\n        is_recent = (today - target_date).days &lt;= 1\n\n        # Load from disk cache on first access (unless --no-cache).\n        if not self._force_cache_refresh:\n            self._load_disk_cache(symbol)\n\n        # 1. Check in-memory cache first (covers disk-loaded and previously\n        #    fetched data). Handles weekends/holidays by looking back 7 days.\n        for days_back in range(8):\n            lookup_date = target_date - timedelta(days=days_back)\n            cached = self._price_cache.get((symbol, lookup_date))\n            if cached is not None:\n                return PricePoint(\n                    symbol=symbol,\n                    price_datetime=datetime.combine(lookup_date, datetime.min.time()),\n                    price=cached,\n                    base_currency=Currency.USD,\n                )\n\n        # 2. For recent dates, try a live bid/ask quote (tbbo for futures,\n        #    cbbo-1m for OPRA). This covers today's price before the daily\n        #    close bar is available.\n        if is_recent:\n            try:\n                ask, bid = self.get_quote(symbol)\n                if ask &gt; 0 and bid &gt; 0:\n                    mid = Decimal(str((ask + bid) / 2)).quantize(Decimal(\"0.0001\"))\n                    return PricePoint(\n                        symbol=symbol,\n                        price_datetime=datetime.now(),\n                        price=mid,\n                        base_currency=Currency.USD,\n                    )\n            except Exception as e:\n                if verbose:\n                    print(f\"  Databento: live quote failed for {symbol}: {e}\", flush=True)\n\n            # Live quote unavailable \u2014 try refreshing cache for recent days.\n            end_dt = datetime.now(timezone.utc) - timedelta(minutes=30)\n            start_dt = datetime.combine(\n                target_date - timedelta(days=10),\n                datetime.min.time(),\n                tzinfo=timezone.utc,\n            )\n            self._populate_cache(symbol, start_dt, end_dt)\n\n            # Check cache again after refresh.\n            for days_back in range(8):\n                lookup_date = target_date - timedelta(days=days_back)\n                cached = self._price_cache.get((symbol, lookup_date))\n                if cached is not None:\n                    return PricePoint(\n                        symbol=symbol,\n                        price_datetime=datetime.combine(lookup_date, datetime.min.time()),\n                        price=cached,\n                        base_currency=Currency.USD,\n                    )\n\n        # 3. Full cache miss \u2014 fetch a broad range and populate the cache.\n        # OPRA cbbo-1m is much denser than futures ohlcv-1d, so use a\n        # shorter prefetch window to avoid excessive API cost.\n        prefetch = 30 if self._is_opra_symbol(symbol) else self._PREFETCH_DAYS\n        end_dt = datetime.now(timezone.utc) - timedelta(minutes=30)\n        if target_date &lt; today:\n            end_dt = datetime.combine(\n                target_date + timedelta(days=1),\n                datetime.min.time(),\n                tzinfo=timezone.utc,\n            )\n        start_dt = datetime.combine(\n            target_date - timedelta(days=prefetch),\n            datetime.min.time(),\n            tzinfo=timezone.utc,\n        )\n\n        self._populate_cache(symbol, start_dt, end_dt)\n\n        # Retry from cache after fetch.\n        for days_back in range(8):\n            lookup_date = target_date - timedelta(days=days_back)\n            cached = self._price_cache.get((symbol, lookup_date))\n            if cached is not None:\n                return PricePoint(\n                    symbol=symbol,\n                    price_datetime=datetime.combine(lookup_date, datetime.min.time()),\n                    price=cached,\n                    base_currency=Currency.USD,\n                )\n\n        raise ValueError(\n            f\"No price data available for {symbol} on {target_date} or the previous 7 days.\"\n        )\n\n    def get_quote(self, symbol: str) -&gt; tuple[float, float]:\n        \"\"\"\n        Get the latest bid/ask prices for a symbol.\n\n        Uses tbbo for futures (GLBX) and cbbo-1m via parent query for\n        options (OPRA).\n\n        Args:\n            symbol: Futures symbol (e.g., \"NGH26\") or OPRA options symbol\n                    (e.g., \"SBUX  260417P00095000\")\n\n        Returns:\n            Tuple of (ask_price, bid_price). Returns (-1.0, -1.0) on error.\n        \"\"\"\n        if self._is_opra_symbol(symbol):\n            return self._get_quote_opra(symbol)\n        return self._get_quote_futures(symbol)\n\n    def _get_quote_futures(self, symbol: str) -&gt; tuple[float, float]:\n        \"\"\"Live quote for futures via tbbo on GLBX.\n\n        Args:\n            symbol: Futures symbol (e.g., \"NGH26\").\n\n        Returns:\n            Tuple of (ask_price, bid_price). Returns (-1.0, -1.0) on error.\n        \"\"\"\n        symbol_variants = [symbol, f\"{symbol}.FUT\", symbol.upper()]\n\n        for sym in symbol_variants:\n            try:\n                client = db.Historical(self._api_key)\n\n                end = datetime.now(timezone.utc) - timedelta(minutes=30)\n                start = end - timedelta(days=3)\n\n                data = client.timeseries.get_range(\n                    dataset=self._dataset,\n                    symbols=sym,\n                    schema=\"tbbo\",\n                    start=start.isoformat(),\n                    end=end.isoformat(),\n                )\n\n                df = data.to_df()\n\n                if df.empty:\n                    continue\n\n                latest = df.iloc[-1]\n                bid_price = float(latest[\"bid_px_00\"])\n                ask_price = float(latest[\"ask_px_00\"])\n                return ask_price, bid_price\n\n            except Exception:\n                continue\n\n        return -1.0, -1.0\n\n    def _get_quote_opra(self, symbol: str) -&gt; tuple[float, float]:\n        \"\"\"Live quote for options via cbbo-1m on OPRA.\n\n        Fetches recent days in one bulk call via _populate_cache_opra,\n        then reads the most recent cached mid-price as bid=ask=mid.\n\n        Args:\n            symbol: OPRA options symbol (e.g., \"SBUX  260417P00095000\").\n\n        Returns:\n            Tuple of (ask_price, bid_price) where both equal the mid-price.\n            Returns (-1.0, -1.0) if no recent data is available.\n        \"\"\"\n        end = datetime.now(timezone.utc) - timedelta(minutes=30)\n        start = end - timedelta(days=5)\n        self._populate_cache_opra(symbol, start, end)\n\n        # Return the most recent cached price as a \"quote\".\n        today = date.today()\n        for days_back in range(8):\n            lookup = today - timedelta(days=days_back)\n            cached = self._price_cache.get((symbol, lookup))\n            if cached is not None:\n                mid = float(cached)\n                return mid, mid  # (ask, bid) \u2014 mid-price for both\n\n        return -1.0, -1.0\n</code></pre>"},{"location":"reference/pricingdata/#athena.pricingdata.DatabentoPricingDataManager.__init__","title":"<code>__init__(api_key=None, dataset=DATASET_CME, force_cache_refresh=False)</code>","text":"<p>Initialize the Databento client.</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str | None</code> <p>Databento API key. If None, reads from DATABENTO_API_KEY env var.</p> <code>None</code> <code>dataset</code> <code>str</code> <p>Databento dataset ID (default: GLBX.MDP3 for CME/NYMEX futures)</p> <code>DATASET_CME</code> <code>force_cache_refresh</code> <code>bool</code> <p>If True, ignore disk cache and fetch fresh from API (but still use in-memory cache within the session).</p> <code>False</code> Source code in <code>src/athena/pricingdata.py</code> <pre><code>def __init__(self, api_key: str | None = None, dataset: str = DATASET_CME,\n             force_cache_refresh: bool = False):\n    \"\"\"Initialize the Databento client.\n\n    Args:\n        api_key: Databento API key. If None, reads from DATABENTO_API_KEY env var.\n        dataset: Databento dataset ID (default: GLBX.MDP3 for CME/NYMEX futures)\n        force_cache_refresh: If True, ignore disk cache and fetch fresh\n            from API (but still use in-memory cache within the session).\n    \"\"\"\n    self._api_key = api_key or os.getenv(\"DATABENTO_API_KEY\")\n    if not self._api_key:\n        raise ValueError(\"Databento API key required. Set DATABENTO_API_KEY env var or pass api_key.\")\n    self._dataset = dataset\n    self._force_cache_refresh = force_cache_refresh\n    # In-memory cache: (symbol, date) \u2192 Decimal close price.\n    self._price_cache: dict[tuple[str, date], Decimal] = {}\n    # Remember which symbol variant resolved for each base symbol so we\n    # skip variants that already failed.\n    self._resolved_variant: dict[str, str] = {}\n    # Track which symbols have been loaded from disk this session.\n    self._disk_loaded: set[str] = set()\n</code></pre>"},{"location":"reference/pricingdata/#athena.pricingdata.DatabentoPricingDataManager.get_price_point","title":"<code>get_price_point(symbol, price_datetime)</code>","text":"<p>Get price for a symbol on a specific date.</p> <p>Supports futures (GLBX.MDP3) and OPRA options (OPRA.PILLAR). OPRA symbols are detected automatically via OSI format parsing.</p> <p>Loads from disk cache on first access (unless --no-cache). Falls back to the Databento API when data is missing. Recent dates (today/yesterday) use live tbbo quotes since ohlcv-1d bars are only available after the trading day ends.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Futures symbol (e.g., \"NGH26\") or OPRA options symbol     (e.g., \"SBUX  260417P00095000\")</p> required <code>price_datetime</code> <code>datetime</code> <p>The datetime to get the price for</p> required <p>Returns:</p> Type Description <code>PricePoint</code> <p>PricePoint with the daily close price (or live mid-price for today)</p> Source code in <code>src/athena/pricingdata.py</code> <pre><code>def get_price_point(self, symbol: str, price_datetime: datetime) -&gt; PricePoint:\n    \"\"\"Get price for a symbol on a specific date.\n\n    Supports futures (GLBX.MDP3) and OPRA options (OPRA.PILLAR).\n    OPRA symbols are detected automatically via OSI format parsing.\n\n    Loads from disk cache on first access (unless --no-cache). Falls back\n    to the Databento API when data is missing. Recent dates\n    (today/yesterday) use live tbbo quotes since ohlcv-1d bars are only\n    available after the trading day ends.\n\n    Args:\n        symbol: Futures symbol (e.g., \"NGH26\") or OPRA options symbol\n                (e.g., \"SBUX  260417P00095000\")\n        price_datetime: The datetime to get the price for\n\n    Returns:\n        PricePoint with the daily close price (or live mid-price for today)\n    \"\"\"\n    target_date = price_datetime.date()\n    today = date.today()\n    is_recent = (today - target_date).days &lt;= 1\n\n    # Load from disk cache on first access (unless --no-cache).\n    if not self._force_cache_refresh:\n        self._load_disk_cache(symbol)\n\n    # 1. Check in-memory cache first (covers disk-loaded and previously\n    #    fetched data). Handles weekends/holidays by looking back 7 days.\n    for days_back in range(8):\n        lookup_date = target_date - timedelta(days=days_back)\n        cached = self._price_cache.get((symbol, lookup_date))\n        if cached is not None:\n            return PricePoint(\n                symbol=symbol,\n                price_datetime=datetime.combine(lookup_date, datetime.min.time()),\n                price=cached,\n                base_currency=Currency.USD,\n            )\n\n    # 2. For recent dates, try a live bid/ask quote (tbbo for futures,\n    #    cbbo-1m for OPRA). This covers today's price before the daily\n    #    close bar is available.\n    if is_recent:\n        try:\n            ask, bid = self.get_quote(symbol)\n            if ask &gt; 0 and bid &gt; 0:\n                mid = Decimal(str((ask + bid) / 2)).quantize(Decimal(\"0.0001\"))\n                return PricePoint(\n                    symbol=symbol,\n                    price_datetime=datetime.now(),\n                    price=mid,\n                    base_currency=Currency.USD,\n                )\n        except Exception as e:\n            if verbose:\n                print(f\"  Databento: live quote failed for {symbol}: {e}\", flush=True)\n\n        # Live quote unavailable \u2014 try refreshing cache for recent days.\n        end_dt = datetime.now(timezone.utc) - timedelta(minutes=30)\n        start_dt = datetime.combine(\n            target_date - timedelta(days=10),\n            datetime.min.time(),\n            tzinfo=timezone.utc,\n        )\n        self._populate_cache(symbol, start_dt, end_dt)\n\n        # Check cache again after refresh.\n        for days_back in range(8):\n            lookup_date = target_date - timedelta(days=days_back)\n            cached = self._price_cache.get((symbol, lookup_date))\n            if cached is not None:\n                return PricePoint(\n                    symbol=symbol,\n                    price_datetime=datetime.combine(lookup_date, datetime.min.time()),\n                    price=cached,\n                    base_currency=Currency.USD,\n                )\n\n    # 3. Full cache miss \u2014 fetch a broad range and populate the cache.\n    # OPRA cbbo-1m is much denser than futures ohlcv-1d, so use a\n    # shorter prefetch window to avoid excessive API cost.\n    prefetch = 30 if self._is_opra_symbol(symbol) else self._PREFETCH_DAYS\n    end_dt = datetime.now(timezone.utc) - timedelta(minutes=30)\n    if target_date &lt; today:\n        end_dt = datetime.combine(\n            target_date + timedelta(days=1),\n            datetime.min.time(),\n            tzinfo=timezone.utc,\n        )\n    start_dt = datetime.combine(\n        target_date - timedelta(days=prefetch),\n        datetime.min.time(),\n        tzinfo=timezone.utc,\n    )\n\n    self._populate_cache(symbol, start_dt, end_dt)\n\n    # Retry from cache after fetch.\n    for days_back in range(8):\n        lookup_date = target_date - timedelta(days=days_back)\n        cached = self._price_cache.get((symbol, lookup_date))\n        if cached is not None:\n            return PricePoint(\n                symbol=symbol,\n                price_datetime=datetime.combine(lookup_date, datetime.min.time()),\n                price=cached,\n                base_currency=Currency.USD,\n            )\n\n    raise ValueError(\n        f\"No price data available for {symbol} on {target_date} or the previous 7 days.\"\n    )\n</code></pre>"},{"location":"reference/pricingdata/#athena.pricingdata.DatabentoPricingDataManager.get_quote","title":"<code>get_quote(symbol)</code>","text":"<p>Get the latest bid/ask prices for a symbol.</p> <p>Uses tbbo for futures (GLBX) and cbbo-1m via parent query for options (OPRA).</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>Futures symbol (e.g., \"NGH26\") or OPRA options symbol     (e.g., \"SBUX  260417P00095000\")</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>Tuple of (ask_price, bid_price). Returns (-1.0, -1.0) on error.</p> Source code in <code>src/athena/pricingdata.py</code> <pre><code>def get_quote(self, symbol: str) -&gt; tuple[float, float]:\n    \"\"\"\n    Get the latest bid/ask prices for a symbol.\n\n    Uses tbbo for futures (GLBX) and cbbo-1m via parent query for\n    options (OPRA).\n\n    Args:\n        symbol: Futures symbol (e.g., \"NGH26\") or OPRA options symbol\n                (e.g., \"SBUX  260417P00095000\")\n\n    Returns:\n        Tuple of (ask_price, bid_price). Returns (-1.0, -1.0) on error.\n    \"\"\"\n    if self._is_opra_symbol(symbol):\n        return self._get_quote_opra(symbol)\n    return self._get_quote_futures(symbol)\n</code></pre>"},{"location":"reference/pricingdata/#athena.pricingdata.get_yfinance_cache_path","title":"<code>get_yfinance_cache_path(symbol)</code>","text":"<p>Get the cache file path for a given symbol.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The ticker symbol (e.g., \"AAPL\", \"MSFT\").</p> required <p>Returns:</p> Type Description <code>Path</code> <p>Path to the CSV cache file under <code>.cache/yfinance_prices/</code>.</p> Source code in <code>src/athena/pricingdata.py</code> <pre><code>def get_yfinance_cache_path(symbol: str) -&gt; Path:\n    \"\"\"Get the cache file path for a given symbol.\n\n    Args:\n        symbol: The ticker symbol (e.g., \"AAPL\", \"MSFT\").\n\n    Returns:\n        Path to the CSV cache file under ``.cache/yfinance_prices/``.\n    \"\"\"\n    return Path.cwd() / \".cache\" / \"yfinance_prices\" / f\"{symbol}.csv\"\n</code></pre>"},{"location":"reference/pricingdata/#athena.pricingdata.fetch_yfinance_data","title":"<code>fetch_yfinance_data(symbol, min_date, max_date, force_cache_refresh=False)</code>","text":"<p>Fetch yfinance data for a symbol, using cache intelligently.</p> <p>If cached data exists, checks if it covers the requested date range. If not, expands the request to include all dates from cache + requested range, then updates the cache with the merged data.</p> <p>Parameters:</p> Name Type Description Default <code>symbol</code> <code>str</code> <p>The ticker symbol (e.g., \"AAPL\", \"MSFT\").</p> required <code>min_date</code> <code>date</code> <p>The minimum date needed.</p> required <code>max_date</code> <code>date</code> <p>The maximum date needed.</p> required <code>force_cache_refresh</code> <code>bool</code> <p>If True, force a fresh fetch from Yahoo Finance (only once per symbol per session).</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: Date, Open, High, Low, Close, Adj Close, Volume.</p> Source code in <code>src/athena/pricingdata.py</code> <pre><code>def fetch_yfinance_data(symbol: str, min_date: date, max_date: date, force_cache_refresh: bool = False) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetch yfinance data for a symbol, using cache intelligently.\n\n    If cached data exists, checks if it covers the requested date range.\n    If not, expands the request to include all dates from cache + requested range,\n    then updates the cache with the merged data.\n\n    Args:\n        symbol: The ticker symbol (e.g., \"AAPL\", \"MSFT\").\n        min_date: The minimum date needed.\n        max_date: The maximum date needed.\n        force_cache_refresh: If True, force a fresh fetch from Yahoo Finance\n            (only once per symbol per session).\n\n    Returns:\n        DataFrame with columns: Date, Open, High, Low, Close, Adj Close, Volume.\n    \"\"\"\n    cache_path = get_yfinance_cache_path(symbol)\n\n    cached_df: pd.DataFrame | None = None\n    cached_min: date | None = None\n    cached_max: date | None = None\n\n    # Always try to read cache first (needed for range calculation and fallback)\n    if cache_path.exists():\n        try:\n            cached_df = pd.read_csv(cache_path, parse_dates=['Date'])  # type: ignore[call-overload]\n            if not cached_df.empty:\n                cached_df['Date'] = pd.to_datetime(cached_df['Date']).dt.date\n                cached_min = cached_df['Date'].min()\n                cached_max = cached_df['Date'].max()\n        except Exception:\n            # If cache is corrupted, we'll just refetch\n            cached_df = None\n\n    # Determine if we need to fetch new data\n    fetch_start = min_date\n    fetch_end = max_date\n\n    # Check if we should force refresh (only once per symbol per session)\n    should_force_refresh = force_cache_refresh and symbol not in _refreshed_symbols\n\n    if should_force_refresh:\n        # Force refresh: fetch fresh data but use cache for range expansion\n        need_fetch = True\n        if cached_df is not None and not cached_df.empty and cached_min is not None and cached_max is not None:\n            # Expand fetch range to cover existing cache too, so we refresh everything\n            fetch_start = min(min_date, cached_min)\n            fetch_end = max(max_date, cached_max)\n    elif cached_df is None or cached_df.empty or cached_min is None or cached_max is None:\n        # No valid cache, fetch the full range\n        need_fetch = True\n    elif min_date &lt; cached_min or max_date &gt; cached_max:\n        # We have cached data but it doesn't cover our range\n        need_fetch = True\n        fetch_start = min(min_date, cached_min)\n        fetch_end = max(max_date, cached_max)\n    else:\n        # Cache covers our range\n        need_fetch = False\n\n    if need_fetch:\n        # Track that we've refreshed this symbol\n        _refreshed_symbols.add(symbol)\n\n        # yfinance end date is exclusive, so add 1 day\n        fetch_end_exclusive = fetch_end + timedelta(days=1)\n\n        if verbose:\n            print(f\"  Fetching {symbol} ({fetch_start} to {fetch_end}) \u2026\", flush=True)\n        try:\n            ticker = yf.Ticker(symbol)\n            new_df: pd.DataFrame = ticker.history(  # type: ignore[call-arg]\n                start=fetch_start.isoformat(),\n                end=fetch_end_exclusive.isoformat(),\n                auto_adjust=False\n            )\n        except Exception as e:\n            # yfinance can fail if Yahoo Finance returns None (e.g., rate limiting,\n            # requesting data for a date with no trading yet, network issues)\n            print(f\"Warning: yfinance request failed for {symbol}: {e}\", file=sys.stderr)\n            if cached_df is not None and not cached_df.empty:\n                return cached_df\n            return pd.DataFrame(columns=['Date', 'Open', 'High', 'Low', 'Close', 'Adj Close', 'Volume'])\n\n        if new_df.empty:\n            # Empty response often indicates rate limiting from Yahoo Finance\n            print(f\"Warning: yfinance returned no data for {symbol} (possible rate limiting)\", file=sys.stderr)\n            # If we got no data but have cache, return cache\n            if cached_df is not None and not cached_df.empty:\n                return cached_df\n            # Otherwise return empty DataFrame with expected columns\n            return pd.DataFrame(columns=['Date', 'Open', 'High', 'Low', 'Close', 'Adj Close', 'Volume'])\n\n        # Reset index to make Date a column\n        new_df = new_df.reset_index()\n        new_df['Date'] = pd.to_datetime(new_df['Date']).dt.date\n\n        # Keep only the columns we need\n        columns_to_keep = ['Date', 'Open', 'High', 'Low', 'Close', 'Adj Close', 'Volume']\n        available_columns = [c for c in columns_to_keep if c in new_df.columns]\n        new_df = new_df[available_columns]\n\n        # Merge with cached data if we had any\n        if cached_df is not None and not cached_df.empty:\n            # Combine and remove duplicates, keeping newer data\n            combined_df = pd.concat([cached_df, new_df], ignore_index=True)\n            combined_df = combined_df.drop_duplicates(subset=['Date'], keep='last')\n            combined_df = combined_df.sort_values('Date').reset_index(drop=True)\n        else:\n            combined_df = new_df.sort_values('Date').reset_index(drop=True)\n\n        # Save to cache\n        cache_path.parent.mkdir(parents=True, exist_ok=True)\n        combined_df.to_csv(cache_path, index=False)\n\n        return combined_df\n\n    # Cache covers our range, return it (we know it's not None here)\n    assert cached_df is not None\n    return cached_df\n</code></pre>"},{"location":"reference/riskfreerates/","title":"riskfreerates","text":""},{"location":"reference/riskfreerates/#athena.riskfreerates","title":"<code>athena.riskfreerates</code>","text":""},{"location":"reference/riskfreerates/#athena.riskfreerates.RiskFreeRateSeries","title":"<code>RiskFreeRateSeries</code>","text":"<p>               Bases: <code>Enum</code></p> <p>FRED series identifiers for risk-free rates.</p> Source code in <code>src/athena/riskfreerates.py</code> <pre><code>class RiskFreeRateSeries(Enum):\n    \"\"\"FRED series identifiers for risk-free rates.\"\"\"\n    DTB3 = \"DTB3\"      # 3-Month Treasury Bill Secondary Market Rate\n    DTB6 = \"DTB6\"      # 6-Month Treasury Bill Secondary Market Rate\n    DTB1YR = \"DTB1YR\"  # 1-Year Treasury Bill Secondary Market Rate\n    DGS1 = \"DGS1\"      # 1-Year Treasury Constant Maturity Rate\n    DGS2 = \"DGS2\"      # 2-Year Treasury Constant Maturity Rate\n    DGS5 = \"DGS5\"      # 5-Year Treasury Constant Maturity Rate\n    DGS10 = \"DGS10\"    # 10-Year Treasury Constant Maturity Rate\n</code></pre>"},{"location":"reference/riskfreerates/#athena.riskfreerates.RiskFreeRateManager","title":"<code>RiskFreeRateManager</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for risk-free rate data providers.</p> Source code in <code>src/athena/riskfreerates.py</code> <pre><code>class RiskFreeRateManager(ABC):\n    \"\"\"Abstract base class for risk-free rate data providers.\"\"\"\n\n    def __init__(\n        self,\n        min_date: date | None = None,\n        max_date: date | None = None\n    ):\n        self.min_date = min_date\n        self.max_date = max_date\n\n    @abstractmethod\n    def get_rate(self, rate_date: date) -&gt; Decimal:\n        \"\"\"\n        Get the annualized risk-free rate for a specific date.\n\n        Args:\n            rate_date: The date to get the rate for.\n\n        Returns:\n            The annualized rate as a decimal (e.g., Decimal(\"0.045\") for 4.5%).\n\n        Raises:\n            ValueError: If no rate is available for the date.\n        \"\"\"\n        raise NotImplementedError(\"This method should be overridden by subclasses.\")\n\n    @abstractmethod\n    def get_daily_rate(self, rate_date: date, trading_days_per_year: int = 252) -&gt; Decimal:\n        \"\"\"\n        Get the daily risk-free rate for a specific date.\n\n        Args:\n            rate_date: The date to get the rate for.\n            trading_days_per_year: Number of trading days per year (default 252).\n\n        Returns:\n            The daily rate as a decimal.\n\n        Raises:\n            ValueError: If no rate is available for the date.\n        \"\"\"\n        raise NotImplementedError(\"This method should be overridden by subclasses.\")\n\n    @abstractmethod\n    def get_rates_for_range(\n        self,\n        start_date: date,\n        end_date: date\n    ) -&gt; dict[date, Decimal]:\n        \"\"\"\n        Get all available annualized rates for a date range.\n\n        Args:\n            start_date: Start of the date range (inclusive).\n            end_date: End of the date range (inclusive).\n\n        Returns:\n            Dictionary mapping dates to annualized rates.\n            Only includes dates where data is available (trading days).\n        \"\"\"\n        raise NotImplementedError(\"This method should be overridden by subclasses.\")\n\n    def get_trading_days_per_year(self) -&gt; int:\n        \"\"\"Return the typical number of trading days per year for US markets.\"\"\"\n        return 252\n</code></pre>"},{"location":"reference/riskfreerates/#athena.riskfreerates.RiskFreeRateManager.get_rate","title":"<code>get_rate(rate_date)</code>  <code>abstractmethod</code>","text":"<p>Get the annualized risk-free rate for a specific date.</p> <p>Parameters:</p> Name Type Description Default <code>rate_date</code> <code>date</code> <p>The date to get the rate for.</p> required <p>Returns:</p> Type Description <code>Decimal</code> <p>The annualized rate as a decimal (e.g., Decimal(\"0.045\") for 4.5%).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no rate is available for the date.</p> Source code in <code>src/athena/riskfreerates.py</code> <pre><code>@abstractmethod\ndef get_rate(self, rate_date: date) -&gt; Decimal:\n    \"\"\"\n    Get the annualized risk-free rate for a specific date.\n\n    Args:\n        rate_date: The date to get the rate for.\n\n    Returns:\n        The annualized rate as a decimal (e.g., Decimal(\"0.045\") for 4.5%).\n\n    Raises:\n        ValueError: If no rate is available for the date.\n    \"\"\"\n    raise NotImplementedError(\"This method should be overridden by subclasses.\")\n</code></pre>"},{"location":"reference/riskfreerates/#athena.riskfreerates.RiskFreeRateManager.get_daily_rate","title":"<code>get_daily_rate(rate_date, trading_days_per_year=252)</code>  <code>abstractmethod</code>","text":"<p>Get the daily risk-free rate for a specific date.</p> <p>Parameters:</p> Name Type Description Default <code>rate_date</code> <code>date</code> <p>The date to get the rate for.</p> required <code>trading_days_per_year</code> <code>int</code> <p>Number of trading days per year (default 252).</p> <code>252</code> <p>Returns:</p> Type Description <code>Decimal</code> <p>The daily rate as a decimal.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no rate is available for the date.</p> Source code in <code>src/athena/riskfreerates.py</code> <pre><code>@abstractmethod\ndef get_daily_rate(self, rate_date: date, trading_days_per_year: int = 252) -&gt; Decimal:\n    \"\"\"\n    Get the daily risk-free rate for a specific date.\n\n    Args:\n        rate_date: The date to get the rate for.\n        trading_days_per_year: Number of trading days per year (default 252).\n\n    Returns:\n        The daily rate as a decimal.\n\n    Raises:\n        ValueError: If no rate is available for the date.\n    \"\"\"\n    raise NotImplementedError(\"This method should be overridden by subclasses.\")\n</code></pre>"},{"location":"reference/riskfreerates/#athena.riskfreerates.RiskFreeRateManager.get_rates_for_range","title":"<code>get_rates_for_range(start_date, end_date)</code>  <code>abstractmethod</code>","text":"<p>Get all available annualized rates for a date range.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>date</code> <p>Start of the date range (inclusive).</p> required <code>end_date</code> <code>date</code> <p>End of the date range (inclusive).</p> required <p>Returns:</p> Type Description <code>dict[date, Decimal]</code> <p>Dictionary mapping dates to annualized rates.</p> <code>dict[date, Decimal]</code> <p>Only includes dates where data is available (trading days).</p> Source code in <code>src/athena/riskfreerates.py</code> <pre><code>@abstractmethod\ndef get_rates_for_range(\n    self,\n    start_date: date,\n    end_date: date\n) -&gt; dict[date, Decimal]:\n    \"\"\"\n    Get all available annualized rates for a date range.\n\n    Args:\n        start_date: Start of the date range (inclusive).\n        end_date: End of the date range (inclusive).\n\n    Returns:\n        Dictionary mapping dates to annualized rates.\n        Only includes dates where data is available (trading days).\n    \"\"\"\n    raise NotImplementedError(\"This method should be overridden by subclasses.\")\n</code></pre>"},{"location":"reference/riskfreerates/#athena.riskfreerates.RiskFreeRateManager.get_trading_days_per_year","title":"<code>get_trading_days_per_year()</code>","text":"<p>Return the typical number of trading days per year for US markets.</p> Source code in <code>src/athena/riskfreerates.py</code> <pre><code>def get_trading_days_per_year(self) -&gt; int:\n    \"\"\"Return the typical number of trading days per year for US markets.\"\"\"\n    return 252\n</code></pre>"},{"location":"reference/riskfreerates/#athena.riskfreerates.FixedRiskFreeRateManager","title":"<code>FixedRiskFreeRateManager</code>","text":"<p>               Bases: <code>RiskFreeRateManager</code></p> <p>Returns a fixed risk-free rate for all dates.</p> Source code in <code>src/athena/riskfreerates.py</code> <pre><code>class FixedRiskFreeRateManager(RiskFreeRateManager):\n    \"\"\"Returns a fixed risk-free rate for all dates.\"\"\"\n\n    def __init__(self, annual_rate: Decimal = Decimal(\"0.05\")):\n        \"\"\"\n        Initialize with a fixed annual rate.\n\n        Args:\n            annual_rate: The fixed annual rate as a decimal (e.g., 0.05 for 5%).\n        \"\"\"\n        super().__init__()\n        self.annual_rate = annual_rate\n\n    def get_rate(self, rate_date: date) -&gt; Decimal:\n        return self.annual_rate\n\n    def get_daily_rate(self, rate_date: date, trading_days_per_year: int = 252) -&gt; Decimal:\n        return self.annual_rate / trading_days_per_year\n\n    def get_rates_for_range(\n        self,\n        start_date: date,\n        end_date: date\n    ) -&gt; dict[date, Decimal]:\n        result: dict[date, Decimal] = {}\n        current = start_date\n        while current &lt;= end_date:\n            result[current] = self.annual_rate\n            current += timedelta(days=1)\n        return result\n</code></pre>"},{"location":"reference/riskfreerates/#athena.riskfreerates.FixedRiskFreeRateManager.__init__","title":"<code>__init__(annual_rate=Decimal('0.05'))</code>","text":"<p>Initialize with a fixed annual rate.</p> <p>Parameters:</p> Name Type Description Default <code>annual_rate</code> <code>Decimal</code> <p>The fixed annual rate as a decimal (e.g., 0.05 for 5%).</p> <code>Decimal('0.05')</code> Source code in <code>src/athena/riskfreerates.py</code> <pre><code>def __init__(self, annual_rate: Decimal = Decimal(\"0.05\")):\n    \"\"\"\n    Initialize with a fixed annual rate.\n\n    Args:\n        annual_rate: The fixed annual rate as a decimal (e.g., 0.05 for 5%).\n    \"\"\"\n    super().__init__()\n    self.annual_rate = annual_rate\n</code></pre>"},{"location":"reference/riskfreerates/#athena.riskfreerates.FREDRiskFreeRateManager","title":"<code>FREDRiskFreeRateManager</code>","text":"<p>               Bases: <code>RiskFreeRateManager</code></p> <p>Risk-free rate manager using FRED (Federal Reserve Economic Data).</p> <p>Fetches Treasury Bill rates directly from FRED's CSV endpoint. Data is cached locally to avoid repeated downloads.</p> Source code in <code>src/athena/riskfreerates.py</code> <pre><code>class FREDRiskFreeRateManager(RiskFreeRateManager):\n    \"\"\"\n    Risk-free rate manager using FRED (Federal Reserve Economic Data).\n\n    Fetches Treasury Bill rates directly from FRED's CSV endpoint.\n    Data is cached locally to avoid repeated downloads.\n    \"\"\"\n\n    def __init__(\n        self,\n        series: RiskFreeRateSeries = RiskFreeRateSeries.DTB3,\n        min_date: date | None = None,\n        max_date: date | None = None,\n        use_cache: bool = True\n    ):\n        \"\"\"\n        Initialize the FRED risk-free rate manager.\n\n        Args:\n            series: The FRED series to use (default: DTB3 - 3-Month T-Bill).\n            min_date: Earliest date to fetch data for (default: 5 years ago).\n            max_date: Latest date to fetch data for (default: today).\n            use_cache: Whether to use local caching (default: True).\n        \"\"\"\n        if min_date is None:\n            min_date = date.today() - timedelta(days=5 * 365)\n        if max_date is None:\n            max_date = date.today()\n\n        super().__init__(min_date, max_date)\n\n        self.series = series\n        self.use_cache = use_cache\n\n        # Dictionary to store rates: {date: Decimal}\n        # Rates are stored as decimals (e.g., 0.045 for 4.5%)\n        self.rates: dict[date, Decimal] = {}\n\n        # Build the FRED CSV URL\n        url = self._build_url(min_date, max_date)\n\n        # Generate cache file path\n        cache_key = hashlib.md5(\n            f\"{series.value}_{min_date}_{max_date}\".encode()\n        ).hexdigest()[:12]\n        self._cache_path = (\n            Path.cwd() / \".cache\" / \"fred_risk_free_rates\" / f\"{series.value}_{cache_key}.csv\"\n        )\n\n        self._fetch_and_parse_data(url)\n\n    def _build_url(self, start_date: date, end_date: date) -&gt; str:\n        \"\"\"Build the FRED CSV download URL.\"\"\"\n        # Format dates as YYYY-MM-DD\n        cosd = start_date.strftime(\"%Y-%m-%d\")\n        coed = end_date.strftime(\"%Y-%m-%d\")\n        today = date.today().strftime(\"%Y-%m-%d\")\n\n        # Simplified FRED URL - only the essential parameters\n        url = (\n            f\"https://fred.stlouisfed.org/graph/fredgraph.csv?\"\n            f\"id={self.series.value}&amp;\"\n            f\"cosd={cosd}&amp;\"\n            f\"coed={coed}&amp;\"\n            f\"fq=Daily&amp;\"\n            f\"fam=avg&amp;\"\n            f\"vintage_date={today}&amp;\"\n            f\"revision_date={today}\"\n        )\n        return url\n\n    def _is_cache_valid(self) -&gt; bool:\n        \"\"\"Check if cache file exists and was modified today.\"\"\"\n        if not self._cache_path.exists():\n            return False\n        mtime = datetime.fromtimestamp(self._cache_path.stat().st_mtime)\n        return mtime.date() == date.today()\n\n    def _fetch_and_parse_data(self, url: str) -&gt; None:\n        \"\"\"Fetch CSV data from FRED and parse it into rates.\"\"\"\n        data: str\n\n        if self.use_cache and self._is_cache_valid():\n            data = self._cache_path.read_text(encoding='utf-8')\n        else:\n            headers = {\n                'User-Agent': (\n                    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) '\n                    'AppleWebKit/537.36 (KHTML, like Gecko) '\n                    'Chrome/120.0.0.0 Safari/537.36'\n                ),\n                'Accept': 'text/csv,text/plain,*/*',\n                'Accept-Language': 'en-US,en;q=0.5',\n            }\n            req = urllib.request.Request(url, headers=headers)\n            with urllib.request.urlopen(req) as response:\n                data = response.read().decode('utf-8')\n\n            if self.use_cache:\n                self._cache_path.parent.mkdir(parents=True, exist_ok=True)\n                self._cache_path.write_text(data, encoding='utf-8')\n\n        # Parse CSV\n        # FRED CSV format:\n        # DATE,DTB3\n        # 2021-01-15,0.09\n        # 2021-01-19,0.08\n        # ...\n        # Note: Missing data is marked as \".\"\n        reader = csv.reader(io.StringIO(data))\n        rows = list(reader)\n\n        if len(rows) &lt; 2:\n            return\n\n        # First row is header, data starts at row 1\n        for row in rows[1:]:\n            if len(row) &lt; 2:\n                continue\n\n            date_str = row[0].strip()\n            value_str = row[1].strip()\n\n            # Skip missing data (FRED uses \".\" for missing values)\n            if value_str == \".\" or not value_str:\n                continue\n\n            try:\n                # Parse date (YYYY-MM-DD format)\n                rate_date = datetime.strptime(date_str, \"%Y-%m-%d\").date()\n\n                # FRED returns rates as percentage points (e.g., 4.5 means 4.5%)\n                # Convert to decimal (e.g., 0.045)\n                rate_pct = Decimal(value_str)\n                rate_decimal = rate_pct / 100\n\n                self.rates[rate_date] = rate_decimal\n\n            except (ValueError, ArithmeticError):\n                continue\n\n    def _get_rate_with_lookback(self, rate_date: date, max_lookback_days: int = 14) -&gt; Decimal | None:\n        \"\"\"\n        Get rate for a date, looking back if not available.\n\n        Args:\n            rate_date: The target date.\n            max_lookback_days: Maximum days to look back for data.\n\n        Returns:\n            The rate if found, None otherwise.\n        \"\"\"\n        for days_back in range(max_lookback_days + 1):\n            lookup_date = rate_date - timedelta(days=days_back)\n            if lookup_date in self.rates:\n                return self.rates[lookup_date]\n        return None\n\n    def get_rate(self, rate_date: date) -&gt; Decimal:\n        \"\"\"\n        Get the annualized risk-free rate for a specific date.\n\n        If no data is available for the exact date (weekend, holiday),\n        looks back up to 14 days to find the most recent trading day.\n\n        Args:\n            rate_date: The date to get the rate for.\n\n        Returns:\n            The annualized rate as a decimal (e.g., Decimal(\"0.045\") for 4.5%).\n\n        Raises:\n            ValueError: If no rate is available for the date or recent history.\n        \"\"\"\n        rate = self._get_rate_with_lookback(rate_date)\n        if rate is None:\n            raise ValueError(\n                f\"No risk-free rate available for {rate_date} \"\n                f\"or the previous 14 days.\"\n            )\n        return rate\n\n    def get_daily_rate(self, rate_date: date, trading_days_per_year: int = 252) -&gt; Decimal:\n        \"\"\"\n        Get the daily risk-free rate for a specific date.\n\n        Converts the annualized rate to a daily rate by dividing by\n        the number of trading days per year.\n\n        Args:\n            rate_date: The date to get the rate for.\n            trading_days_per_year: Number of trading days per year (default 252).\n\n        Returns:\n            The daily rate as a decimal.\n\n        Raises:\n            ValueError: If no rate is available for the date.\n        \"\"\"\n        annual_rate = self.get_rate(rate_date)\n        return annual_rate / trading_days_per_year\n\n    def get_rates_for_range(\n        self,\n        start_date: date,\n        end_date: date\n    ) -&gt; dict[date, Decimal]:\n        \"\"\"\n        Get all available annualized rates for a date range.\n\n        Only returns dates where actual FRED data exists (trading days).\n        Does not interpolate or carry forward rates.\n\n        Args:\n            start_date: Start of the date range (inclusive).\n            end_date: End of the date range (inclusive).\n\n        Returns:\n            Dictionary mapping dates to annualized rates (as decimals).\n        \"\"\"\n        result: dict[date, Decimal] = {}\n        for rate_date, rate in self.rates.items():\n            if start_date &lt;= rate_date &lt;= end_date:\n                result[rate_date] = rate\n        return result\n\n    def get_available_dates(self) -&gt; list[date]:\n        \"\"\"\n        Get all dates for which rate data is available.\n\n        Returns:\n            Sorted list of dates with available data.\n        \"\"\"\n        return sorted(self.rates.keys())\n</code></pre>"},{"location":"reference/riskfreerates/#athena.riskfreerates.FREDRiskFreeRateManager.__init__","title":"<code>__init__(series=RiskFreeRateSeries.DTB3, min_date=None, max_date=None, use_cache=True)</code>","text":"<p>Initialize the FRED risk-free rate manager.</p> <p>Parameters:</p> Name Type Description Default <code>series</code> <code>RiskFreeRateSeries</code> <p>The FRED series to use (default: DTB3 - 3-Month T-Bill).</p> <code>DTB3</code> <code>min_date</code> <code>date | None</code> <p>Earliest date to fetch data for (default: 5 years ago).</p> <code>None</code> <code>max_date</code> <code>date | None</code> <p>Latest date to fetch data for (default: today).</p> <code>None</code> <code>use_cache</code> <code>bool</code> <p>Whether to use local caching (default: True).</p> <code>True</code> Source code in <code>src/athena/riskfreerates.py</code> <pre><code>def __init__(\n    self,\n    series: RiskFreeRateSeries = RiskFreeRateSeries.DTB3,\n    min_date: date | None = None,\n    max_date: date | None = None,\n    use_cache: bool = True\n):\n    \"\"\"\n    Initialize the FRED risk-free rate manager.\n\n    Args:\n        series: The FRED series to use (default: DTB3 - 3-Month T-Bill).\n        min_date: Earliest date to fetch data for (default: 5 years ago).\n        max_date: Latest date to fetch data for (default: today).\n        use_cache: Whether to use local caching (default: True).\n    \"\"\"\n    if min_date is None:\n        min_date = date.today() - timedelta(days=5 * 365)\n    if max_date is None:\n        max_date = date.today()\n\n    super().__init__(min_date, max_date)\n\n    self.series = series\n    self.use_cache = use_cache\n\n    # Dictionary to store rates: {date: Decimal}\n    # Rates are stored as decimals (e.g., 0.045 for 4.5%)\n    self.rates: dict[date, Decimal] = {}\n\n    # Build the FRED CSV URL\n    url = self._build_url(min_date, max_date)\n\n    # Generate cache file path\n    cache_key = hashlib.md5(\n        f\"{series.value}_{min_date}_{max_date}\".encode()\n    ).hexdigest()[:12]\n    self._cache_path = (\n        Path.cwd() / \".cache\" / \"fred_risk_free_rates\" / f\"{series.value}_{cache_key}.csv\"\n    )\n\n    self._fetch_and_parse_data(url)\n</code></pre>"},{"location":"reference/riskfreerates/#athena.riskfreerates.FREDRiskFreeRateManager.get_rate","title":"<code>get_rate(rate_date)</code>","text":"<p>Get the annualized risk-free rate for a specific date.</p> <p>If no data is available for the exact date (weekend, holiday), looks back up to 14 days to find the most recent trading day.</p> <p>Parameters:</p> Name Type Description Default <code>rate_date</code> <code>date</code> <p>The date to get the rate for.</p> required <p>Returns:</p> Type Description <code>Decimal</code> <p>The annualized rate as a decimal (e.g., Decimal(\"0.045\") for 4.5%).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no rate is available for the date or recent history.</p> Source code in <code>src/athena/riskfreerates.py</code> <pre><code>def get_rate(self, rate_date: date) -&gt; Decimal:\n    \"\"\"\n    Get the annualized risk-free rate for a specific date.\n\n    If no data is available for the exact date (weekend, holiday),\n    looks back up to 14 days to find the most recent trading day.\n\n    Args:\n        rate_date: The date to get the rate for.\n\n    Returns:\n        The annualized rate as a decimal (e.g., Decimal(\"0.045\") for 4.5%).\n\n    Raises:\n        ValueError: If no rate is available for the date or recent history.\n    \"\"\"\n    rate = self._get_rate_with_lookback(rate_date)\n    if rate is None:\n        raise ValueError(\n            f\"No risk-free rate available for {rate_date} \"\n            f\"or the previous 14 days.\"\n        )\n    return rate\n</code></pre>"},{"location":"reference/riskfreerates/#athena.riskfreerates.FREDRiskFreeRateManager.get_daily_rate","title":"<code>get_daily_rate(rate_date, trading_days_per_year=252)</code>","text":"<p>Get the daily risk-free rate for a specific date.</p> <p>Converts the annualized rate to a daily rate by dividing by the number of trading days per year.</p> <p>Parameters:</p> Name Type Description Default <code>rate_date</code> <code>date</code> <p>The date to get the rate for.</p> required <code>trading_days_per_year</code> <code>int</code> <p>Number of trading days per year (default 252).</p> <code>252</code> <p>Returns:</p> Type Description <code>Decimal</code> <p>The daily rate as a decimal.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no rate is available for the date.</p> Source code in <code>src/athena/riskfreerates.py</code> <pre><code>def get_daily_rate(self, rate_date: date, trading_days_per_year: int = 252) -&gt; Decimal:\n    \"\"\"\n    Get the daily risk-free rate for a specific date.\n\n    Converts the annualized rate to a daily rate by dividing by\n    the number of trading days per year.\n\n    Args:\n        rate_date: The date to get the rate for.\n        trading_days_per_year: Number of trading days per year (default 252).\n\n    Returns:\n        The daily rate as a decimal.\n\n    Raises:\n        ValueError: If no rate is available for the date.\n    \"\"\"\n    annual_rate = self.get_rate(rate_date)\n    return annual_rate / trading_days_per_year\n</code></pre>"},{"location":"reference/riskfreerates/#athena.riskfreerates.FREDRiskFreeRateManager.get_rates_for_range","title":"<code>get_rates_for_range(start_date, end_date)</code>","text":"<p>Get all available annualized rates for a date range.</p> <p>Only returns dates where actual FRED data exists (trading days). Does not interpolate or carry forward rates.</p> <p>Parameters:</p> Name Type Description Default <code>start_date</code> <code>date</code> <p>Start of the date range (inclusive).</p> required <code>end_date</code> <code>date</code> <p>End of the date range (inclusive).</p> required <p>Returns:</p> Type Description <code>dict[date, Decimal]</code> <p>Dictionary mapping dates to annualized rates (as decimals).</p> Source code in <code>src/athena/riskfreerates.py</code> <pre><code>def get_rates_for_range(\n    self,\n    start_date: date,\n    end_date: date\n) -&gt; dict[date, Decimal]:\n    \"\"\"\n    Get all available annualized rates for a date range.\n\n    Only returns dates where actual FRED data exists (trading days).\n    Does not interpolate or carry forward rates.\n\n    Args:\n        start_date: Start of the date range (inclusive).\n        end_date: End of the date range (inclusive).\n\n    Returns:\n        Dictionary mapping dates to annualized rates (as decimals).\n    \"\"\"\n    result: dict[date, Decimal] = {}\n    for rate_date, rate in self.rates.items():\n        if start_date &lt;= rate_date &lt;= end_date:\n            result[rate_date] = rate\n    return result\n</code></pre>"},{"location":"reference/riskfreerates/#athena.riskfreerates.FREDRiskFreeRateManager.get_available_dates","title":"<code>get_available_dates()</code>","text":"<p>Get all dates for which rate data is available.</p> <p>Returns:</p> Type Description <code>list[date]</code> <p>Sorted list of dates with available data.</p> Source code in <code>src/athena/riskfreerates.py</code> <pre><code>def get_available_dates(self) -&gt; list[date]:\n    \"\"\"\n    Get all dates for which rate data is available.\n\n    Returns:\n        Sorted list of dates with available data.\n    \"\"\"\n    return sorted(self.rates.keys())\n</code></pre>"}]}